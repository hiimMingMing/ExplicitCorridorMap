<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SD.Tools.Algorithmia</name>
    </assembly>
    <members>
        <member name="T:SD.Tools.Algorithmia.Commands.Command`1">
            <summary>
            Command class which performs a command on a given object. What is performed is set by a lambda expression. State is contained inside this object.
            This is a typical implementation of the Command pattern, with undo/redo capabilities. See: http://en.wikipedia.org/wiki/Command_pattern
            </summary>
            <typeparam name="TState">The type of the state preserved inside the command.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.#ctor(System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.Command`1"/> class.
            </summary>
            <param name="doFunc">The do func, used for performing the Do operation, which is a func which doesn't accept any parameters.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.#ctor(System.Action,System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.Command`1"/> class.
            </summary>
            <param name="doFunc">The do func, used for performing the Do operation, which is a func which doesn't accept any parameters.</param>
            <param name="undoFunc">The undo func.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.#ctor(System.Action,System.Action,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.Command`1"/> class.
            </summary>
            <param name="doFunc">The do func, used for performing the Do operation, which is a func which doesn't accept any parameters.</param>
            <param name="undoFunc">The undo func.</param>
            <param name="description">The description of the command.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.#ctor(System.Action,System.Func{`0},System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.Command`1"/> class.
            </summary>
            <param name="doFunc">The do func, used for performing the Do operation, which is a func which doesn't accept any parameters.</param>
            <param name="getStateFunc">The get state func, which is the func to use to get the state.</param>
            <param name="undoFunc">The undo func, which is the func to undo the action performed by the doFunc. Can be the same as
            doFunc.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.#ctor(System.Action,System.Func{`0},System.Action{`0},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.Command`1"/> class.
            </summary>
            <param name="doFunc">The do func, used for performing the Do operation, which is a func which doesn't accept any parameters.</param>
            <param name="getStateFunc">The get state func, which is the func to use to get the state.</param>
            <param name="undoFunc">The undo func, which is the func to undo the action performed by the doFunc. Can be the same as
            doFunc.</param>
            <param name="description">The description of the command.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.DoNow(System.Action)">
            <summary>
            Enqueues and runs a new command by passing the function specified. Use this shortcut to wrap several statements into a single undo block.
            </summary>
            <param name="doFunc">The do func.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.DoNow(System.Action,System.Action)">
            <summary>
            Enqueues and runs a new command by passing the function specified. Use this shortcut to wrap several statements into a single undo block.
            </summary>
            <param name="doFunc">The do func.</param>
            <param name="undoFunc">The undo func.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.DoNow(System.Action,System.Action,System.String)">
            <summary>
            Enqueues and runs a new command by passing the function specified. Use this shortcut to wrap several statements into a single undo block.
            </summary>
            <param name="doFunc">The do func.</param>
            <param name="undoFunc">The undo func.</param>
            <param name="description">The description.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.Do">
            <summary>
            Executes the command.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.Command`1.Undo">
            <summary>
            Undo's the action done with <see cref="M:SD.Tools.Algorithmia.Commands.Command`1.Do"/>.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.CommandBase">
            <summary>
            Abstract base class for command classes to use in the Command pattern implementation. A base class is used instead of an interface to be able to 
            keep the Do and Undo methods internal, as execution of commands should be done through the CommandQueue instances.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.CommandBase"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.CommandBase"/> class.
            </summary>
            <param name="description">The description.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.Redo">
            <summary>
            Re-executes the command. Normally this is simply calling 'Do', however in an undoable period redo it's calling PerformRedo.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.PushCommandQueueOnActiveStackIfRequired">
            <summary>
            Pushes the command queue on active stack if required.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.PopCommandQueueFromActiveStackIfRequired">
            <summary>
            Pops the command queue from active stack if required.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.PerformRedo">
            <summary>
            Performs the redo action.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.Do">
            <summary>
            Executes the command.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandBase.Undo">
            <summary>
            Undo's the action done with <see cref="M:SD.Tools.Algorithmia.Commands.CommandBase.Do"/>.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandBase.OwnCommandQueue">
            <summary>
            Gets the own command queue of this command. This queue is then used to store commands which are spawned when this command is executed.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandBase.Description">
            <summary>
            Gets or sets the description of the command. This description can be used to show the commands in a queue visually on a screen. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandBase.BeforeDoAction">
            <summary>
            Gets or sets the before Do action, which is an action executed right before Do is called on this command
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandBase.AfterDoAction">
            <summary>
            Gets or sets the after Do action, which is an action executed right after Do has been called on this command
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandBase.BeforeUndoAction">
            <summary>
            Gets or sets the before Undo action, which is an action executed right before Undo is called on this command
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandBase.AfterUndoAction">
            <summary>
            Gets or sets the after Undo action, which is an action executed right after Undo has been called on this command
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.CommandQueue">
            <summary>
            Class which is used as a command queue to store commands to execute. Supports undo/redo. 
            </summary>
            <remarks>This command queue uses the policy that the current command pointer points to the command which has been executed the last time. It can only be 
            null if it hasn't executed any commands or if the queue is empty.
            This policy is different from the policy where the current command pointer points to the command which is about to be executed: as the execution of a command
            can spawn commands, it first has to move to the command executed, and then execute it, otherwise there is a state where the current command pointer is actually
            the command which was executed last (as the new command to enqueue is spawned during execution of the command), because the move to the new command happens after
            the command has been executed in full. 
            </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.CommandQueue"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.EnqueueCommand(SD.Tools.Algorithmia.Commands.CommandBase)">
            <summary>
            Enqueues the command specified and makes it the current command.
            </summary>
            <param name="toEnqueue">To enqueue.</param>
            <returns>true if enqueue action succeeded, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.RedoCurrentCommand">
            <summary>
            Calls the current command's Redo() method, if there's a command left to execute. It first makes the next command the current command and then executes it.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.DoCurrentCommand">
            <summary>
            Calls the current command's Do() method, if there's a command left to execute. It first makes the next command the current command and then executes it.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.PerformDoRedoCommand(System.Boolean)">
            <summary>
            Performs the do / redo action on the current command.
            </summary>
            <param name="performRedo">if set to <see langword="true"/> perform a redo, otherwise perform a do.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.UndoPreviousCommand">
            <summary>
            Calls the last executed command's Undo method, if there's was a command last executed. It then makes the previous command the current command.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.DequeueLastExecutedCommand">
            <summary>
            Dequeues the last executed command. This is done in periods which aren't undoable.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.MovePrevious">
            <summary>
            Moves the previous.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.MoveNext">
            <summary>
            Moves the current command to the next command in the queue.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueue.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueue.UndoInProgress">
            <summary>
            Gets or sets a value indicating whether an undo action is in progress. If an undo action is in progress, no commands can be added to this queue, as 
            those commands will never be undoable nor processable in a normal way: undo actions should restore state with direct actions. Adding commands to a queue
            which is in an undo action will cause an exception. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueue.CanUndo">
            <summary>
            Gets a value indicating whether this command queue can undo the last executed command (so there are commands left to undo) (true), or false if no more
            commands can be undone in this queue.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueue.CanDo">
            <summary>
            Gets a value indicating whether this command queue can do a current command (so there's a command left to execute) (true) or false if no more commands
            can be executed in this queue.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueue.ActiveCommand">
            <summary>
            Gets the active command in this queue.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueue.Count">
            <summary>
            Gets the number of commands in this queue
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs">
            <summary>
            Simple class for the event args for the CommandQueueActionPerformed event raised in the CommandQueueManager instance.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs.#ctor(SD.Tools.Algorithmia.CommandQueueActionType,System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs"/> class.
            </summary>
            <param name="actionType">Type of the action.</param>
            <param name="activeCommandStackId">The active command stack id. The command is executed on a queue in the stack with this id. Observers
            should examine this id and decide whether they act upon this event or ignore it (e.g. the command was on a different stack)</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs.ActionPerformed">
            <summary>
            Gets or sets the action performed.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs.ActiveCommandStackId">
            <summary>
            Gets or sets the active command stack id. The command is executed on a queue in the stack with this id. Observers
            should examine this id and decide whether they act upon this event or ignore it (e.g. the command was on a different stack)
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.CommandQueueManagerSingleton">
            <summary>
            Singleton provider for the actual CommandQueueManager class which manages the command queues. There's one instance per <i>appDomain</i>. 
            One thread can have access to the instance at any given time. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManagerSingleton.#cctor">
            <summary>
            Initializes the <see cref="T:SD.Tools.Algorithmia.Commands.CommandQueueManagerSingleton"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManagerSingleton.GetInstance">
            <summary>
            Gets the single CommandQueueManager instance.
            </summary>
            <returns>the CommandQueueManager instance managed by this singleton.</returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.CommandQueueManager">
            <summary>
            Class which in in charge of managing the command queues of the application. It is used in combination of a singleton provider as there's just
            one instance alive in the application. 
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.Commands.CommandQueueManager._inUndoablePeriod">
            <summary>
            per thread store a flag which signals if the command manager is in a special mode called 'an undoable period', which means 'Redo' commands 
            execute their queues and 'Undo' commands don't clear the queue, plus newly queued commands are ignored. Only set if an UndoablePeriod is Undone/Redone, 
            otherwise false.
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.Commands.CommandQueueManager.ThrowExceptionOnDoDuringUndo">
            <summary>
            Flag to signal the CommandQueueManager and command objects whether to throw a DoDuringUndoException if a Do action is detected during an Undo action.
            When set to false, the Do action is ignored. Default is true. Leave to true to easily detect bugs in code which utilizes Do/Undo functionality.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Commands.CommandQueueManager.CommandQueueActionPerformed">
            <summary>
            Event which is raised when a command queue action has been performed. Use this event to update observer objects which track changes in the command queue
            manager. Raised in the same critical action block as the action itself, so the thread which started the action is also raising this event. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.CommandQueueManager"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.ActivateCommandQueueStack(System.Guid)">
            <summary>
            Activates the command queue stack related to the stackId specified, or if there's no stack yet, it creates a new one. 
            </summary>
            <param name="stackId">The stack id of the stack to activate. Each different part of the application which has to have its own stack of queues
            uses its own stackId. If the Empty guid is passed in, it will de-activate the current active queue stack and will make the main queue stack, the one
            owned by CommandQueueManager, the active queue.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.ResetActiveCommandQueue">
            <summary>
            Resets the active command queue stack. This means that the stack will get all its commands be removed and an empty queue is the result.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.BeginNonUndoablePeriod">
            <summary>
            Starts a period of command execution which aren't undoable. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.EndNonUndoablePeriod">
            <summary>
            Ends the non-undoable period started with BeginNonUndoablePeriod. Commands enqueued and ran after this method will be undoable again. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.BeginUndoablePeriod(SD.Tools.Algorithmia.Commands.UndoablePeriodCommand)">
            <summary>
            Sets the command manager in a special mode where all subsequential commands are tracked inside an UndoablePeriodCommand which, when undone/redone
            will not destroy its command queue during undo and won't accept new commands when redone, which is useful when you want to mark a method as an
            undoable piece of code and the method creates objects, which can be a problem with a normal command calling the method because the objects created
            inside the method are re-created (so you'll get new instances) when the command is redone. If follow up commands work on the instances, redoing these
            commands as well causes a problem as they'll work on objects which aren't there.
            </summary>
            <param name="cmd">The command to use for the undoableperiod.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.EndUndoablePeriod(SD.Tools.Algorithmia.Commands.UndoablePeriodCommand)">
            <summary>
            Ends the undoable period started with BeginUndoablePeriod.
            </summary>
            <param name="cmd">The command used for the undoable period.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.PerformUndoablePeriod(SD.Tools.Algorithmia.Commands.UndoablePeriodCommand,System.Action)">
            <summary>
            Performs the code func inside an undoable period guarded by the command specified. Use this method if the code to run inside the 
            undoable period is well known and can be wrapped inside a single func. The func codeToExecuteInPeriodFunc is executed once, all
            undo/redo logic is done by undo/redo-ing commands which were ran due to state changes caused by codeToExecuteInPeriodFunc.
            If you want to run a command again during redo, you should enqueue and run a normal command instead of using this method.
            To create an undoable period, you can also call BeginUndoablePeriod and EndUndoablePeriod.
            </summary>
            <param name="cmd">The CMD.</param>
            <param name="codeToExecuteInPeriodFunc">The code to execute in period func.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.CanDo(System.Guid)">
            <summary>
            Determines whether the commandqueuestack with the id passed in can perform a Do operation (or redo)
            </summary>
            <param name="stackId">The stack id.</param>
            <returns>true if the stack contains a command which can be performed, false otherwise.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.CanUndo(System.Guid)">
            <summary>
            Determines whether the commandqueuestack with the id passed in can perform an Undo operation
            </summary>
            <param name="stackId">The stack id.</param>
            <returns>true if the stack contains a command which can be undone, false otherwise.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.EnqueueCommand(SD.Tools.Algorithmia.Commands.CommandBase)">
            <summary>
            Enqueues the command in the top queue on the active stack. It expects there is an active command queue: if it's not one activated by the callee, it's the
            one belonging to this manager, which owns its own main queue. 
            </summary>
            <param name="toEnqueue">The command to enqueue.</param>
            <returns>true if enqueue action succeeded, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.EnqueueAndRunCommand(SD.Tools.Algorithmia.Commands.CommandBase)">
            <summary>
            Enqueues and runs the command in the top queue on the active stack. It expects there is an active command queue: if it's not one activated by 
            the callee, it's the one belonging to this manager, which owns its own main queue. 
            </summary>
            <param name="toEnqueueAndRun">The command to enqueue and run.</param>
            <remarks>If enqueue action fails due to an undo action that's in progress and ThrowExceptionOnDoDuringUndo is set to false, this routine is a no-op</remarks>
            <returns>true if enqueue and Do succeeded, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.UndoLastCommand">
            <summary>
            Undo'es the last command in the top queue
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.RedoLastCommand">
            <summary>
            Redo'es the last command in the top queue.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.GetActiveCommandQueueStack">
            <summary>
            Gets the command queue stack currently active in the manager for the active thread
            </summary>
            <returns>The active command queue stack or null if no stack was active</returns>
            <remarks>'Active' is relative to a thread. This means that the returned stack is the active stack for the active thread and should not be passed
            to other threads as being the active stack as for every thread a different stack could be active</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.GetCommandQueueStackForId(System.Guid)">
            <summary>
            Gets the command queue stack related to the stackid passed in
            </summary>
            <param name="stackId">The stack id of the stack to return. Each different part of the application which has to have its own stack of queues
            uses its own stackId. If the Empty guid is passed in, it will return the main queue stack, the one owned by CommandQueueManager.</param>
            <returns>The stack related to the stackid passed in or null if the stack isn't found</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.PushCommandQueueOnActiveStack(SD.Tools.Algorithmia.Commands.CommandQueue)">
            <summary>
            Pushes the command queue passed in onto the active stack. This is done when a command is about to be executed. 
            </summary>
            <param name="toPush">Command queue to push.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.PopCommandQueueFromActiveStack">
            <summary>
            Pops the top command queue from the active stack. Done when a command has been executed
            </summary>
            <returns>the command queue at the top of the active stack</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.SetUndoablePeriodFlag(System.Boolean)">
            <summary>
            Sets the undoable period flag.
            </summary>
            <param name="value">the value to set the flag to.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.RaiseCommandQueueActionPerformed(SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs)">
            <summary>
            Raises the CommandQueueActionPerformed event.
            </summary>
            <param name="eventArgs">The <see cref="T:SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.ThreadEnter">
            <summary>
            Entrance routine for a thread call to this class. Called from every public method at the very beginning.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueManager.ThreadExit">
            <summary>
            Exit routine for a thread call to this class. Called from every public method at the end.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueueManager.RaiseEvents">
            <summary>
            Gets/ sets the RaiseEvents flag. By default, events are raised when an action is performed. To stop this from happening, call this method and pass false.
            This flag is for all threads. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueueManager.IsInUndoablePeriod">
            <summary>
            Gets a value indicating whether this instance is in an undoable period.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueueManager.IsInNonUndoablePeriod">
            <summary>
            Gets a value indicating whether this instance is in a non undoable period.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.CommandQueueStack">
            <summary>
            Class which represents a command queue stack, which is used to keep all command queues of a given context together.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.CommandQueueStack.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.CommandQueueStack"/> class.
            </summary>
            <param name="stackId">The stack id.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.Commands.CommandQueueStack.StackId">
            <summary>
            Gets the StackId.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.DoDuringUndoException">
            <summary>
            Exception class which is thrown when a Do action is detected during an Undo action.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.DoDuringUndoException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.DoDuringUndoException"/> class.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Commands.UndoablePeriodCommand">
            <summary>
            Special command class which marks an Undoable Period. It doesn't perform a command itself, but marks a start and an end to other commands to be 
            threated as a single undoable/redoable unit. It has special features: redo will re-do all contained commands and will put the CommandManager
            in a special state which blocks any new commands being queued during redo. Undo will not clear the queues after a queue is completely undone. 
            The advantage of an undoable period is that it doesn't call methods to do things (like a command would) and therefore can be used to mark a method
            which creates new objects as an undoable period while all actions performed on datastructures inside that method are tracked in the queue
            of this command. 
            An Undoable Period is to be used with undo/redo areas where new objects are created and stored in datastructures. Re-doing these kind of areas with
            normal commands will re-create new instances which causes problems with follow up commands if these are re-done too: those commands work on the
            previous objects perhaps, causing problems along te way. With an undoable period you can prevent this from happening as any method which is 
            called through a command should be replaced with a normal method call and inside the method you should mark the code as an undoable period.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.UndoablePeriodCommand.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Commands.UndoablePeriodCommand"/> class.
            </summary>
            <param name="description">The description of the undoable period.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.UndoablePeriodCommand.Redo">
            <summary>
            Re-executes the command. Normally this is simply calling 'Do', however in an undoable period redo it's calling PerformRedo.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.UndoablePeriodCommand.Do">
            <summary>
            Executes the command.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Commands.UndoablePeriodCommand.Undo">
            <summary>
            Undo's the action done with <see cref="M:SD.Tools.Algorithmia.Commands.UndoablePeriodCommand.Do"/>.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.SortDirection">
            <summary>
            Enum for specifying the sort direction for the various sort algorithms
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.SortDirection.Ascending">
            <summary>
            Sort ascending
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.SortDirection.Descending">
            <summary>
            Sort descending
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.SortAlgorithm">
            <summary>
            Enum for specifying the sort algorithm to use
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.SortAlgorithm.SelectionSort">
            <summary>
            Use selection sort to sort the source
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.SortAlgorithm.ShellSort">
            <summary>
            Use shell sort to sort the source
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.SortAlgorithm.QuickSort">
            <summary>
            Use quick sort to sort the source
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.CommandQueueActionType">
            <summary>
            Enum for specifying the command queue action type in the CommandQueueActionPerformedEventArgs objects.
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.CommandQueueActionType.CommandExecuted">
            <summary>
            A command was executed
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.CommandQueueActionType.CommandEnqueued">
            <summary>
            A command was enqueued
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.CommandQueueActionType.UndoPerformed">
            <summary>
            A command was undo-ed
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.CommandQueueActionType.RedoPerformed">
            <summary>
            A command was redo-ed
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.CommandQueueActionType.CommandQueuePushed">
            <summary>
            A command's command queue was pushed onto the command stack. (so any spawned commands are enqueued inside the command itself)
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.CommandQueueActionType.CommandQueuePopped">
            <summary>
            A command's command queue was popped from the command stack. 
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.CommandQueueActionType.CommandDequeued">
            <summary>
            A command was dequeued and the current command pointer was pushed back.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter">
            <summary>
            Class which limits calls to a method by using a timer which effectively calls the method instead. To limit calls to a given method, 
            pass it as a lambda to the method <see cref="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action,System.Double,System.ComponentModel.ISynchronizeInvoke)"/>. The first time <see cref="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action,System.Double,System.ComponentModel.ISynchronizeInvoke)"/> is called, a timer is started and the lambda
            is stored. When the timer elapses after the specified number of milliseconds, the stored lambda is called and the timer is reset, though
            not started again. When <see cref="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action,System.Double,System.ComponentModel.ISynchronizeInvoke)"/> is called while the timer is running (so between the first call and the moment the timer elapses)
            the call is ignored. This way you can limit calls to a given method to 1 per interval. This is useful for situation where you have a lot of 
            events coming from different sources which all result in a single call to a given method. 
            </summary>
            <remarks>Be aware that if no synchronizationcontext is specified, the call to the lambda specified to <see cref="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action,System.Double,System.ComponentModel.ISynchronizeInvoke)"/> will be done on
            another thread, namely the one the timer runs on</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action)">
            <summary>
            Calls the specified to call after 500ms milliseconds, unless a call is already in progress, in which case the call is ignored. It doesn't matter if
            this method was called previously with a different toCall value. 
            </summary>
            <param name="toCall">The func to call.</param>
            <remarks>Calls to toCall will be made on a threadpool thread</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action,System.Double)">
            <summary>
            Calls the specified to call after intervalMS milliseconds, unless a call is already in progress, in which case the call is ignored. It doesn't matter if
            this method was called previously with a different toCall value.
            </summary>
            <param name="toCall">The func to call.</param>
            <param name="intervalMS">The interval to wait, in ms, before toCall is called. If interval is below 100, it's clamped to 100.</param>
            <returns>true if the call is accepted and will be performed in intervalMS ms. False if the call is ignored if a timer is 
            already in progress.</returns>
            <remarks>Calls to toCall will be made on a threadpool thread</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action,System.Double,System.ComponentModel.ISynchronizeInvoke)">
            <summary>
            Calls the specified to call after intervalMS milliseconds, unless a call is already in progress, in which case the call is ignored. It doesn't matter if
            this method was called previously with a different toCall value.
            </summary>
            <param name="toCall">The func to call.</param>
            <param name="intervalMS">The interval to wait, in ms, before toCall is called. If interval is below 100, it's clamped to 100.</param>
            <param name="synchronizingObject">The synchronizing object. If null, the call to the lambda specified to <see cref="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter.Call(System.Action,System.Double,System.ComponentModel.ISynchronizeInvoke)"/> might be done on a different thread, as the System
            timer used is using a threadpool in that case. If the call has to be the same thread as the UI, specify a UI object
            as synchronizingObject, e.g. a form object or control object on which this limiter is used.</param>
            <returns>true if the call is accepted and will be performed in intervalMS ms. False if the call is ignored if a timer is 
            already in progress.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CallLimiter._timer_Elapsed(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            Handles the Elapsed event of the timer object.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The <see cref="T:System.Timers.ElapsedEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3">
            <summary>
            Class which extends KeyedCommandifiedList so that it picks up detailed changes in elements in this list and propagates them to subscribers in a single event.
            Subscribers therefore don't have to subscribe to all detailed change events of all the elements in the list. 
            </summary>
            <remarks>This class can be a synchronized collection by passing true for isSynchronized in the constructor. To synchronize access to the contents of this class, 
            lock on the SyncRoot object. This class uses the same lock for its internal elements as the base class as these elements are related to the elements of the base class</remarks>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3.DetailedElementInListChanged">
            <summary>
            Raised when an element in this list raised its DetailedElementChanged event. The event args contain detailed information about what was changed. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3.#ctor(System.Func{`0,`1},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3"/> class.
            </summary>
            <param name="keyValueProducerFunc">The key value producer func.</param>
            <param name="keyPropertyName">Name of the key property which is used to track changes in individual elements.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3.#ctor(System.Func{`0,`1},System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3" /> class.
            </summary>
            <param name="keyValueProducerFunc">The key value producer func.</param>
            <param name="keyPropertyName">Name of the key property which is used to track changes in individual elements.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3.OnAddingItem(`0)">
            <summary>
            Called right before the item passed in is about to be added to this list. Use this method to do event handler housekeeping on elements in this list.
            </summary>
            <param name="item">The item which is about to be added.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3.OnRemovingItemComplete(`0)">
            <summary>
            Called right after the item passed in has been removed from this list.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ChangeAwareKeyedCommandifiedList`3.item_DetailedElementChanged(System.Object,SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs{`2,`0})">
            <summary>
            Handles the DetailedElementChanged event of the item control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1">
            <summary>
            Generic list class which is command-aware: it performs its actions through commands, so all actions on this list are undoable. 
            </summary>
            <typeparam name="T">The type of the element inside the list.</typeparam>
            <remarks>This class implements IBindingList and not WPF's INotifyCollectionChanged, because the latter isn't recognized
            by Winforms controls, hence the IBindingList interface implementation. Due to the nature of IBindingList, an extra event has been added
            for retrieving a removed element by an observer<br/><br/>
            This class can be a synchronized collection by passing true for isSynchronized in the constructor. To synchronize access to the contents of this class, 
            lock on the <see cref="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SyncRoot"/> object.</remarks>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ListChanged">
            <summary>
            Occurs when the list changes or an item in the list changes.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ElementRemoved">
            <summary>
            Raised when an element was removed from this list. The element removed is contained in the event arguments. This event is necessary to 
            be able to retrieve a removed element after it was removed from the list by an observer, as ListChanged only contains indexes, and the
            index of a removed element isn't valid after it's been removed from the list. 
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ElementAdding">
            <summary>
            Raised when an element is about to be added. The addition of the element can be cancelled through the event arguments. 
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ElementRemoving">
            <summary>
            Raised when an element is about to be removed. The removal of the element can be cancelled through the event arguments. 
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ListClearing">
            <summary>
            Raised when this list is about to be cleared completely. The clearing of the list can be cancelled through the event arguments. 
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ListCommandType">
            <summary>
            Enum for finding back command descriptions. These descriptions are cached because they'd otherwise overflow the GC memory with string fragments
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1"/> class. This instance is not synchronized.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1" /> class.
            </summary>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on <see cref="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SyncRoot"/> to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements in the range specified to this list in one command
            </summary>
            <param name="elementsToAdd">The elements to add.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ResetBindings">
            <summary>
            Resets the bindings. Raises a ListChanged.Reset event
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.MoveElement(System.Int32,System.Int32)">
            <summary>
            Moves the element at index currentIndex to the indexToMoveTo index. 
            </summary>
            <param name="currentIndex">Index of the current.</param>
            <param name="indexToMoveTo">The index to move to.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ClearItems">
            <summary>
            Removes all elements from the <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts an element into the <see cref="T:System.Collections.ObjectModel.Collection`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert. The value can be null for reference types.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.-or-<paramref name="index"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.</exception>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.RemoveItem(System.Int32)">
            <summary>
            Removes the element at the specified index of the <see cref="T:System.Collections.ObjectModel.Collection`1"/>.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.-or-<paramref name="index"/> is equal to or greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.</exception>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index. The value can be null for reference types.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.-or-<paramref name="index"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.</exception>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.OnClearing">
            <summary>
            Called right before the clear action starts. Use this method to do event handler housekeeping on elements in this list. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.OnRemovingItem(`0)">
            <summary>
            Called right before the item passed in is about to be removed from this list. Use this method to do event handler housekeeping on elements in this list. 
            </summary>
            <param name="item">The item which is about to be removed.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.OnAddingItem(`0)">
            <summary>
            Called right before the item passed in is about to be added to this list. Use this method to do event handler housekeeping on elements in this list. 
            </summary>
            <param name="item">The item which is about to be added.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.OnRemovingItemComplete(`0)">
            <summary>
            Called right after the item passed in has been removed from this list. 
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.OnAddingItemComplete(`0)">
            <summary>
            Called right after the item passed in has been added to the list
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.OnClearingComplete">
            <summary>
            Called right after the clear action has been completed. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.OnElementPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Called when the PropertyChanged event was raised by an element in this list.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.NotifyChange(System.ComponentModel.ListChangedType,System.Int32,System.Int32)">
            <summary>
            Notifies a list change to observers with the parameters passed in.
            </summary>
            <param name="changeType">Type of the change.</param>
            <param name="oldIndex">The old index.</param>
            <param name="newIndex">The new index.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.PerformSyncedAction(System.Action)">
            <summary>
            Performs the specified action, either inside a lock on <see cref="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SyncRoot"/> if this list is Synchronized, or normally, if this list isn't synchronized.
            </summary>
            <param name="toPerform">To perform.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.PerformSyncedAction``1(System.Func{``0})">
            <summary>
            Performs the specified action, either inside a lock on <see cref="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SyncRoot"/> if this list is Synchronized, or normally, if this list isn't synchronized.
            </summary>
            <typeparam name="TFunc">The type of the element to return</typeparam>
            <param name="toPerform">To perform.</param>
            <returns>the result of toPerform</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.NotifyElementRemoved(`0)">
            <summary>
            Notifies observers that an element has been removed.
            </summary>
            <param name="itemRemoved">The item removed.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.BuildCachedCommandDescriptions">
            <summary>
            Builds the cached command descriptions.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.GetCurrentState">
            <summary>
            Gets the current state of this collection, which is simply a copy of the items into another collection.
            </summary>
            <returns>a collection with all items in this collection in the same order. </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SetCurrentState(System.Collections.Generic.IList{`0})">
            <summary>
            Sets the state of this collection to the passed in state. This means: removing all elements and then setting it back to the state passed in.
            </summary>
            <param name="state">The state.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.VerifyIndex(System.Int32)">
            <summary>
            Verifies the index.
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.BindToINotifyPropertyChanged(`0)">
            <summary>
            Binds to INotifyPropertyChanged on the item specified
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.UnbindFromINotifyPropertyChanged(`0)">
            <summary>
            Unbinds from INotifyPropertyChanged on the item specified
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.PerformClearItems">
            <summary>
            Performs the ClearItems call.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.PerformInsertItem(System.Int32,`0)">
            <summary>
            Performs the InsertItem call
            </summary>
            <param name="index">The index.</param>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.PerformRemoveItem(System.Int32)">
            <summary>
            Performs the RemoveItem call
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.PerformSetItem(System.Int32,`0)">
            <summary>
            Performs the SetItem call
            </summary>
            <param name="index">The index.</param>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.AddIndex(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Adds the <see cref="T:System.ComponentModel.PropertyDescriptor"/> to the indexes used for searching.
            </summary>
            <param name="property">The <see cref="T:System.ComponentModel.PropertyDescriptor"/> to add to the indexes used for searching.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.AddNew">
            <summary>
            Adds a new item to the list.
            </summary>
            <returns>The item added to the list.</returns>
            <exception cref="T:System.NotSupportedException">
            	<see cref="P:System.ComponentModel.IBindingList.AllowNew"/> is false. </exception>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.AllowEdit">
            <summary>
            Gets whether you can update items in the list.
            </summary>
            <value></value>
            <returns>true if you can update the items in the list; otherwise, false.</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.AllowNew">
            <summary>
            Gets whether you can add items to the list using <see cref="M:System.ComponentModel.IBindingList.AddNew"/>.
            </summary>
            <value></value>
            <returns>true if you can add items to the list using <see cref="M:System.ComponentModel.IBindingList.AddNew"/>; otherwise, false.</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.AllowRemove">
            <summary>
            Gets whether you can remove items from the list, using <see cref="M:System.Collections.IList.Remove(System.Object)"/> or <see cref="M:System.Collections.IList.RemoveAt(System.Int32)"/>.
            </summary>
            <value></value>
            <returns>true if you can remove items from the list; otherwise, false.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)">
            <summary>
            Sorts the list based on a <see cref="T:System.ComponentModel.PropertyDescriptor"/> and a <see cref="T:System.ComponentModel.ListSortDirection"/>.
            </summary>
            <param name="property">The <see cref="T:System.ComponentModel.PropertyDescriptor"/> to sort by.</param>
            <param name="direction">One of the <see cref="T:System.ComponentModel.ListSortDirection"/> values.</param>
            <exception cref="T:System.NotSupportedException">
            	<see cref="P:System.ComponentModel.IBindingList.SupportsSorting"/> is false. </exception>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.Find(System.ComponentModel.PropertyDescriptor,System.Object)">
            <summary>
            Returns the index of the row that has the given <see cref="T:System.ComponentModel.PropertyDescriptor"/>.
            </summary>
            <param name="property">The <see cref="T:System.ComponentModel.PropertyDescriptor"/> to search on.</param>
            <param name="key">The value of the <paramref name="property"/> parameter to search for.</param>
            <returns>
            The index of the row that has the given <see cref="T:System.ComponentModel.PropertyDescriptor"/>.
            </returns>
            <exception cref="T:System.NotSupportedException">
            	<see cref="P:System.ComponentModel.IBindingList.SupportsSearching"/> is false. </exception>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.IsSorted">
            <summary>
            Gets whether the items in the list are sorted.
            </summary>
            <value></value>
            <returns>true if <see cref="M:System.ComponentModel.IBindingList.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)"/> has been called and <see cref="M:System.ComponentModel.IBindingList.RemoveSort"/> has not been called; otherwise, false.</returns>
            <exception cref="T:System.NotSupportedException">
            	<see cref="P:System.ComponentModel.IBindingList.SupportsSorting"/> is false. </exception>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.RemoveIndex(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Removes the <see cref="T:System.ComponentModel.PropertyDescriptor"/> from the indexes used for searching.
            </summary>
            <param name="property">The <see cref="T:System.ComponentModel.PropertyDescriptor"/> to remove from the indexes used for searching.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.RemoveSort">
            <summary>
            Removes any sort applied using <see cref="M:System.ComponentModel.IBindingList.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">
            	<see cref="P:System.ComponentModel.IBindingList.SupportsSorting"/> is false. </exception>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SortDirection">
            <summary>
            Gets the direction of the sort.
            </summary>
            <value></value>
            <returns>One of the <see cref="T:System.ComponentModel.ListSortDirection"/> values.</returns>
            <exception cref="T:System.NotSupportedException">
            	<see cref="P:System.ComponentModel.IBindingList.SupportsSorting"/> is false. </exception>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SortProperty">
            <summary>
            Gets the <see cref="T:System.ComponentModel.PropertyDescriptor"/> that is being used for sorting.
            </summary>
            <value></value>
            <returns>The <see cref="T:System.ComponentModel.PropertyDescriptor"/> that is being used for sorting.</returns>
            <exception cref="T:System.NotSupportedException">
            	<see cref="P:System.ComponentModel.IBindingList.SupportsSorting"/> is false. </exception>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SupportsChangeNotification">
            <summary>
            Gets whether a <see cref="E:System.ComponentModel.IBindingList.ListChanged"/> event is raised when the list changes or an item in the list changes.
            </summary>
            <value></value>
            <returns>true if a <see cref="E:System.ComponentModel.IBindingList.ListChanged"/> event is raised when the list changes or when an item changes; otherwise, false.</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SupportsSearching">
            <summary>
            Gets whether the list supports searching using the <see cref="M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)"/> method.
            </summary>
            <value></value>
            <returns>true if the list supports searching using the <see cref="M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)"/> method; otherwise, false.</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SupportsSorting">
            <summary>
            Gets whether the list supports sorting.
            </summary>
            <value></value>
            <returns>true if the list supports sorting; otherwise, false.</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SuppressEvents">
            <summary>
            Gets or sets a value indicating whether events are blocked from being raised (true) or not (false, default)
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe). Default: false. Set to true in the ctor to 
            make sure the operations on this object are using locks. Use <see cref="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SyncRoot"/> to lock on the same object as this class' internal operations.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />. It's the same object used in locks inside this object. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedList`1.Item(System.Int32)">
            <summary>
            Gets or sets the instance at the specified index. This is a redefinition, so the get can be synchronized if needed.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2">
            <summary>
            Class which represents a member variable which is commandified, so setting the value occurs through commands.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TChangeType">The type of the change type enum.</typeparam>
            <remarks>Resets error messages on successful set of a value, or if the field is set to the same value.
            Binds to the HasBeenChanged event of TValue, if it implements INotifyAsChanged, and raises ValueChanged if HasBeenChanged is raised on an element.
            Binds to the HasBeenRemoved event of TValue, if it implements INotifyAsRemoved, and raises ValueElementRemoved if HasBeenRemoved is raised
            on an element.</remarks>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.ErrorReset">
            <summary>
            Event which is raised explicitly to signal subscribers that the error has been reset. This event is only raised if there's a necessity for it:
            If there's an error set and this object was set to the same value, resetting the error, subscribers don't know the error has been reset as the
            member value itself won't be changed. This event will notify them that the error has been reset and they should raise a Propertychanged event to
            notify UI elements that they can clear ErrorInfo providers. 
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.ValueChanged">
            <summary>
            Event which is raised when MemberValue is set to a different value. If MemberValue's value is a mutable object and implements INotifyElementChanged, the 
            event is also raised when some values inside the value object change. In that case, the original value and the new value in the event args
            are the same. 
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.ValueElementRemoved">
            <summary>
            Event which is raised when the value implements INotifyElementRemoved and it got removed from its container. This event
            is used in that situation to notify observers that the value of this CommandifiedMember is no longer usable. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.#ctor(System.String,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2"/> class.
            </summary>
            <param name="memberName">Name of the member.</param>
            <param name="changeTypeValueToUse">The change type value to use.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.#ctor(System.String,`1,SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2"/> class.
            </summary>
            <param name="memberName">Name of the member.</param>
            <param name="changeTypeValueToUse">The change type value to use.</param>
            <param name="loggedErrors">container for error messages. Can be null.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.#ctor(System.String,`1,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2"/> class.
            </summary>
            <param name="memberName">Name of the member.</param>
            <param name="changeTypeValueToUse">The change type value to use.</param>
            <param name="initialValue">The initial value.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.#ctor(System.String,`1,SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2"/> class.
            </summary>
            <param name="memberName">Name of the member.</param>
            <param name="changeTypeValueToUse">The change type value to use.</param>
            <param name="loggedErrors">The logged errors container.</param>
            <param name="initialValue">The initial value.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.UnbindFromElementChanged">
            <summary>
            Unbinds from the ElementChanged event
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.UnbindFromElementRemoved">
            <summary>
            Unbinds from the ElementRemoved event
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.BindToElementChanged">
            <summary>
            Binds to INotifyElementChanged.ElementChanged on the value set in memberValue, if supported.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.BindToElementRemoved">
            <summary>
            Binds to the ElementRemoved event
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.SetInitialValue(`0)">
            <summary>
            Sets the initial value of this commandified member. It does this by bypassing the actual member set function.
            Use this method to avoid events being raised while setting the value and also when you want to avoid using commands to set the value, as the
            memberValue is set without using commands. No validation occurs as well, so only use this if you want to set the initial value after the ctor 
            has already been called. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.OnMemberSetToSameValue">
            <summary>
            Called when the member is set to the same value it already has
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.ValidateMemberValue(`0,System.Boolean,System.Boolean,`0@)">
            <summary>
            Validates the member value.
            </summary>
            <param name="valueToValidate">The value to validate.</param>
            <param name="checkForDuplicates">if set to true, it will check for duplicate names</param>
            <param name="throwOnError">if set to true, it will throw a ValidationException if validation failed</param>
            <param name="correctValue">The correct value.</param>
            <returns>
            true if the member is valid, false otherwise
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.OnBeforeMemberValueSet(`0)">
            <summary>
            Called before the membervalue is about to be set to the value specified. 
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.OnAfterMemberValueSet">
            <summary>
            Called after the membervalue has been set to a new value.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.ResetErrorForMember">
            <summary>
            Resets the error for member.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.SetMemberValue(`0)">
            <summary>
            Sets the member value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2._memberValue_ElementChanged(System.Object,System.EventArgs)">
            <summary>
            Handles the ElementChanged event of the _memberValue control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The <see cref="T:System.EventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2._memberValue_ElementRemoved(System.Object,System.EventArgs)">
            <summary>
            Handles the ElementRemoved event of the _memberValue control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The <see cref="T:System.EventArgs"/> instance containing the event data.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.ThrowExceptionOnValidationError">
            <summary>
            Gets or sets a value indicating whether an exception should be thrown if validation fails (true, default) or not (false)
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.MemberName">
            <summary>
            Gets the name of the member.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.LoggedErrors">
            <summary>
            Gets the logged errors.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.CommandifiedMember`2.MemberValue">
            <summary>
            Gets or sets the member value.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.MemberValueElementChangedHandler">
            <summary>
            Delegate for the member value changed handler
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.MemberValueElementRemovedHandler">
            <summary>
            Delegate for the member value removed handler
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EditableObjectDataContainer">
            <summary>
            Class which is used to implement IEditableObject on objects. It tracks state and performs actions. 
            </summary>
            <remarks>To use this container, implement IEditableObject on a class and simply call the BeginEdit/EndEdit and CancelEdit of an instance of
            this class in the BeginEdit/EndEdit/CancelEdit methods of the IEditableObject implementation. Set DatabindingContainer of the instance
            of this class to the container collection in the container collection's IBindingList.AddNew() implementation.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EditableObjectDataContainer.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EditableObjectDataContainer"/> class.
            </summary>
            <param name="editedObject">The edited object for which this container implements IEditableObject.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EditableObjectDataContainer.BeginEdit">
            <summary>
            Begins an edit on an object.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EditableObjectDataContainer.CancelEdit">
            <summary>
            Discards changes since the last <see cref="M:System.ComponentModel.IEditableObject.BeginEdit"/> call.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EditableObjectDataContainer.EndEdit">
            <summary>
            Pushes changes since the last <see cref="M:System.ComponentModel.IEditableObject.BeginEdit"/> or <see cref="M:System.ComponentModel.IBindingList.AddNew"/> call into the underlying object.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EditableObjectDataContainer.DatabindingContainer">
            <summary>
            Sets the databinding container. Set this property in IBindingList.AddNew().
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EqualityComparers.CommandQueueActionPerformedEventArgsEqualityComparer">
            <summary>
            An IEqualityComparer usable to compare CommandQueueActionPerformedEventArgs objects.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EqualityComparers.CommandQueueActionPerformedEventArgsEqualityComparer.Equals(SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs,SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs)">
            <summary>
            Compares x with y and returns true if they're equal. This is a value-based comparison (so InvolvedElement and changetype are equal)
            </summary>
            <param name="x">first element to compare</param>
            <param name="y">second element to compare</param>
            <returns>true if x and y represent the same event arguments, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EqualityComparers.CommandQueueActionPerformedEventArgsEqualityComparer.GetHashCode(SD.Tools.Algorithmia.Commands.CommandQueueActionPerformedEventArgs)">
            <summary>
            Returns a hash code for the specified object. 
            </summary>
            <param name="obj">The instance to return the hascode for.</param>
            <returns>A hash code for the specified object</returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EqualityComparers.ElementChangedEventArgsComparer`2">
            <summary>
            An IEqualityComparer usable to compare ElementChangedEventArgs objects.
            </summary>
            <typeparam name="TChangeType">The type of the change type. Assumed to be an enum type</typeparam>
            <typeparam name="TElement">The type of the element.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EqualityComparers.ElementChangedEventArgsComparer`2.Equals(SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs{`0,`1},SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs{`0,`1})">
            <summary>
            Compares x with y and returns true if they're equal. This is a value-based comparison (so InvolvedElement and changetype are equal)
            </summary>
            <param name="x">first element to compare</param>
            <param name="y">second element to compare</param>
            <returns>true if x and y represent the same event arguments, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EqualityComparers.ElementChangedEventArgsComparer`2.GetHashCode(SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs{`0,`1})">
            <summary>
            Returns a hash code for the specified object. 
            </summary>
            <param name="obj">The instance to return the hascode for.</param>
            <returns>A hash code for the specified object</returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer">
            <summary>
            Simple class which is used as a container for error information for IDataErrorInfo implementations. 
            </summary>
            <remarks>Instead of doing housekeeping of error info in every class which implements IDataErrorInfo, you can use an instance of
            this class to do it for you. Simply set the errors in this class and retrieve the error info in the IDataErrorInfo implementation of your own class.
            <br/><br/>
            This class is thread safe.
            </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer"/> class.
            </summary>
            <param name="defaultError">The default error message to return by IDataErrorInfo.Error.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.ClearErrors">
            <summary>
            Clears the errors contained in this container
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.GetAllPropertyNamesWithErrors">
            <summary>
            Gets all property names with errors stored in this errorcontainer. Use the names to index into this container to obtain the error for this particular
            property. Properties with an empty string as error are ignored.
            </summary>
            <returns></returns>
            <remarks>This method traverses the inner structures with a filter without locking. To make sure a call to this method is thread safe, lock on 
            <see cref="P:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.SyncRoot"/> </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.ConvertToNewLineDelimitedList(System.Boolean)">
            <summary>
            Converts all property-error pairs to a new-line delimited string .
            </summary>
            <param name="prefixEachLineWithDash">if set to <see langword="true"/> each line is prefixed with a '-'</param>
            <returns></returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.SetPropertyError(System.String,System.String)">
            <summary>
            Sets the property error. If an empty errorDescription is passed in, the error information is cleared. Always logs a hard error.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="errorDescription">The error description.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.SetPropertyError(System.String,System.String,System.Boolean)">
            <summary>
            Sets the property error. If an empty errorDescription is passed in, the error information is cleared.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="errorDescription">The error description.</param>
            <param name="isSoftError">if set to <see langword="true"/> the error is considered 'soft', which means it's cleared after it's been read.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.AppendPropertyError(System.String,System.String)">
            <summary>
            Appends the property error to an existing error for that property. Appends a newline first.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="errorDescription">The error description.</param>
            <remarks>To remove an error message for a property, call SetPropertyError with an empty string as error message.
            Always logs a hard error</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.AppendPropertyError(System.String,System.String,System.Boolean)">
            <summary>
            Appends the property error to an existing error for that property. Appends a newline first.
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="errorDescription">The error description.</param>
            <param name="isSoftError">if set to <see langword="true"/> the error is considered 'soft', which means it's cleared after it's been read.</param>
            <remarks>To remove an error message for a property, call SetPropertyError with an empty string as error message.
            Overwrites the existing isSoftError flag value of the existing error of the property with the value specified in isSoftError</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.AppendPropertyError(System.String,System.String,System.String)">
            <summary>
            Appends the property error to an existing error for that property. Appends the lineSeparator to the existing error first. 
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="errorDescription">The error description.</param>
            <param name="lineSeparator">The line separator to append to the existing error message.</param>
            <remarks>To remove an error message for a property, call SetPropertyError with an empty string as error message.
            Always logs a hard error</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.AppendPropertyError(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Appends the property error to an existing error for that property. Appends the lineSeparator to the existing error first. 
            </summary>
            <param name="propertyName">Name of the property.</param>
            <param name="errorDescription">The error description.</param>
            <param name="lineSeparator">The line separator to append to the existing error message.</param>
            <param name="isSoftError">if set to <see langword="true"/> the error is considered 'soft', which means it's cleared after it's been read.</param>
            <remarks>To remove an error message for a property, call SetPropertyError with an empty string as error message.
            Overwrites the existing isSoftError flag value of the existing error of the property with the value specified in isSoftError</remarks>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.Error">
            <summary>
            Gets an error message indicating what is wrong with this object.
            </summary>
            <returns>
            An error message indicating what is wrong with this object. The default is an empty string ("").
            </returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.Item(System.String)">
            <summary>
            Gets the <see cref="T:System.String"/> with the specified column name.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ErrorContainer.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />. It's the same object used in locks inside this object. 
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CancelableListModificationEventArgs`1">
            <summary>
            Event args class which is used in events which are cancelable and which arguments have to contain the element involved to allow observers
            to examine the element involved to better decide what to do: cancel or allow.
            </summary>
            <typeparam name="T">type of the elements contained in the raising container class</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CancelableListModificationEventArgs`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CancelableListModificationEventArgs`1"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CancelableListModificationEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CancelableListModificationEventArgs`1"/> class.
            </summary>
            <param name="involvedElement">The involved element.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CancelableListModificationEventArgs`1.Cancel">
            <summary>
            Gets or sets a value indicating whether the event raised and passing this event arguments instance is cancelled or not.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CancelableListModificationEventArgs`1.InvolvedElement">
            <summary>
            Gets or sets the involved element.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CollectionElementRemovedEventArgs`1">
            <summary>
            Event args class which is used in ElementRemoved events in CommandifiedList. 
            </summary>
            <typeparam name="T">type of the elements contained in the raising container class</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CollectionElementRemovedEventArgs`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CollectionElementRemovedEventArgs`1"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CollectionElementRemovedEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CollectionElementRemovedEventArgs`1"/> class.
            </summary>
            <param name="involvedElement">The involved element.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.CollectionElementRemovedEventArgs`1.InvolvedElement">
            <summary>
            Gets or sets the involved element.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ContainerEventArgs`1">
            <summary>
            A generic container event args which is useful if you want to raise an event and pass a single value along to the subscribers.
            </summary>
            <typeparam name="TValue">The type of the value contained in the event args.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ContainerEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ContainerEventArgs`1"/> class.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ContainerEventArgs`1.Value">
            <summary>
            Gets or sets the value contained in the event args
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs`2">
            <summary>
            Custom event argument class which is used to signal a change in an element.
            </summary>
            <typeparam name="TChangeType">The type of the change type. Has to be an enum</typeparam>
            <typeparam name="TElement">The type of the involved element.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs`2.#ctor(`0,`1)">
            <summary>
            CTor
            </summary>
            <param name="typeOfChange">The change type to pass on to subscribers</param>
            <param name="involvedElement">The involved element which was changed.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs`2.TypeOfChange">
            <summary>
            Gets / sets typeOfChange
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementChangedEventArgs`2.InvolvedElement">
            <summary>
            Gets or sets the involved element. Can be null in the situation where this event args is used in change events on commandified members.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementInListChangedEventArgs`2">
            <summary>
            Event args for the event raised from a list to signal that an element inside the list has been changed.
            </summary>
            <typeparam name="TChangeType">The type of the change type.</typeparam>
            <typeparam name="TElement">The type of the element.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementInListChangedEventArgs`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementInListChangedEventArgs`2"/> class.
            </summary>
            <param name="typeOfChange">The type of change.</param>
            <param name="involvedElement">The involved element which was changed.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementInListChangedEventArgs`2.InvolvedElement">
            <summary>
            Gets or sets the involved element.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.ElementInListChangedEventArgs`2.TypeOfChange">
            <summary>
            Gets or sets the type of change 
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.MemberChangedEventArgs`2">
            <summary>
            Custom event argument class which is used to signal a change in a commandified member
            </summary>
            <remarks>When the value is a mutable object and its contents is mutated, a commandified member containing that value will raise its ValueChanged
            event. In that case, originalValue and newValue will be the same.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.MemberChangedEventArgs`2.#ctor(`0,`1,`1)">
            <summary>
            CTor
            </summary>
            <param name="typeOfChange">The change type to pass on to subscribers</param>
            <param name="originalValue">The original value.</param>
            <param name="newValue">The new value.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.MemberChangedEventArgs`2.TypeOfChange">
            <summary>
            Gets / sets typeOfChange
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.MemberChangedEventArgs`2.NewValue">
            <summary>
            Gets or sets the new value. OriginalValue and NewValue differ when the member raising the event this argument is used in is set to a new value.
            Original and NewValue are equal if the value of the member raising this event is changed internally (if it's mutable) and it implements INotifyElementChanged
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventArguments.MemberChangedEventArgs`2.OriginalValue">
            <summary>
            Gets or sets the original value. OriginalValue and NewValue differ when the member raising the event this argument is used in is set to a new value.
            Original and NewValue are equal if the value of the member raising this event is changed internally (if it's mutable) and it implements INotifyElementChanged
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2">
            <summary>
            Class which throttles an event pipeline. It offers unique event raising during a fixed interval.
            Instances collect events and with each interval only the unique events (last event first) from that batch are raised. Every event 
            found in the batch which is equal to an already raised event (which has equal event arguments) is ignored. Use this class to limit a 
            large amount of events which are equal and lead to e.g. repainting a UI, to act like a event instead. This can greatly increase performance in 
            scenarios where events are used to manipulate UI objects or other objects and repetitive changes lead to the same situation (e.g. 100 times the
            event that an element has changed in a short time (e.g. 100ms) where each time a TreeNode is repainted because 'the element has changed' is redundant:
            the last event in the batch is enough, it already repaints the node completely).
            <br/><br/>
            Events are compared based on the event args, which are compared to event arguments already processed. Use one throttler per event handler.
            </summary>
            <typeparam name="TElement">The type of the element involved in the event. If possible, use a more specific object than the event sender.</typeparam>
            <typeparam name="TEventArgs">The type of the event args.</typeparam>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.EventThrottled">
            <summary>
            Raised when a unique event was throttled from the task queue and approved to be processed by observers. 
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.QueueProcessingStarted">
            <summary>
            Raised when the queue processing was started.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.QueueProcessingFinished">
            <summary>
            Raised when the queue processing was finished.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.#ctor(System.ComponentModel.ISynchronizeInvoke)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2"/> class.
            </summary>
            <param name="synchronizingObject">The synchronizing object. If null, the EventThrottled event might be raised by a different thread, as the System
            timer used for queue processing is using a threadpool in that case. If the handler has to run on the same thread as the UI, specify a UI object
            as synchronizingObject, e.g. a form object or control object on which this throttler is used.</param>
            <remarks>Uses an interval of 500 and the default comparer</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.#ctor(System.ComponentModel.ISynchronizeInvoke,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2"/> class.
            </summary>
            <param name="synchronizingObject">The synchronizing object. If null, the EventThrottled event might be raised by a different thread, as the System
            timer used for queue processing is using a threadpool in that case. If the handler has to run on the same thread as the UI, specify a UI object
            as synchronizingObject, e.g. a form object or control object on which this throttler is used.</param>
            <param name="interval">The interval, in milliseconds. If smaller than 100, it's set to 500</param>
            <remarks>Uses the default comparer</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.#ctor(System.ComponentModel.ISynchronizeInvoke,System.Int32,System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2"/> class.
            </summary>
            <param name="synchronizingObject">The synchronizing object. If null, the EventThrottled event might be raised by a different thread, as the System
            timer used for queue processing is using a threadpool in that case. If the handler has to run on the same thread as the UI, specify a UI object
            as synchronizingObject, e.g. a form object or control object on which this throttler is used.</param>
            <param name="interval">The interval, in milliseconds. If smaller than 100, it's set to 500</param>
            <param name="eventArgsComparer">The event args comparer. Can be null, in which the default equality comparer is used.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.Clear">
            <summary>
            Clears this instance's queued tasks and stops the timer, if it was set.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.EnqueueEvent(`0,`1)">
            <summary>
            Enqueues the event in the task queue.
            </summary>
            <param name="involvedElement">The involved element. This doesn't have to be the sender. Preverably this is the element involved in the
            event.</param>
            <param name="eventArgs">The TEventArgs instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2._timer_Elapsed(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            Handles the Elapsed event of the _timer control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The <see cref="T:System.Timers.ElapsedEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2.Enabled">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.EventThrottler`2"/> is enabled. If disabled, it simply re-raises
            the events enqueued.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.ExtensionMethods">
            <summary>
            Extension methods for classes defined in the GeneralDataStructures namespace
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ExtensionMethods.ToMultiValueDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Converts an enumerable into a MultiValueDictionary. Similar to ToDictionary however this time the returned type is a MultiValueDictionary.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="source">The source.</param>
            <param name="keySelectorFunc">The key selector func.</param>
            <returns>MultiValueDictionary with the values of source stored under the keys retrieved by the keySelectorFunc which is applied to each
            value in source, or null if source is null</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ExtensionMethods.SplitPairs``4(System.Collections.Generic.IEnumerable{SD.Tools.Algorithmia.GeneralDataStructures.Pair{``0,``1}},System.Collections.Generic.List{``2},System.Collections.Generic.List{``3})">
            <summary>
            Splits the pairs in the enumerable into two lists of values where the pair at position x in source equals to values1[x], values2[x]
            </summary>
            <typeparam name="TValue1">The type of the Value1 property.</typeparam>
            <typeparam name="TValue2">The type of the Value2 property.</typeparam>
            <typeparam name="TValue3">The type of the elements in values1. TValue1 has to be casteable to TValue3.</typeparam>
            <typeparam name="TValue4">The type of the eleemnts in values2. TValue2 has to be casteable to TValue4.</typeparam>
            <param name="source">The source.</param>
            <param name="values1">The list of all Value1 values in the pairs in source.</param>
            <param name="values2">The list of all Value2 values in the pairs in source.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ExtensionMethods.RaiseEvent(SD.Tools.Algorithmia.GeneralDataStructures.MemberValueElementChangedHandler,System.Object)">
            <summary>
            Raises the event on the handler passed in with default empty arguments
            </summary>
            <param name="handler">The handler.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ExtensionMethods.RaiseEvent``1(SD.Tools.Algorithmia.GeneralDataStructures.MemberValueElementChangedHandler,System.Object,``0)">
            <summary>
            Raises the event which is represented by the handler specified. 
            </summary>
            <typeparam name="T">type of the event args</typeparam>
            <param name="handler">The handler of the event to raise.</param>
            <param name="sender">The sender of the event.</param>
            <param name="arguments">The arguments to pass to the handler.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ExtensionMethods.RaiseEvent(SD.Tools.Algorithmia.GeneralDataStructures.MemberValueElementRemovedHandler,System.Object)">
            <summary>
            Raises the event on the handler passed in with default empty arguments
            </summary>
            <param name="handler">The handler.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ExtensionMethods.RaiseEvent``1(SD.Tools.Algorithmia.GeneralDataStructures.MemberValueElementRemovedHandler,System.Object,``0)">
            <summary>
            Raises the event which is represented by the handler specified. 
            </summary>
            <typeparam name="T">type of the event args</typeparam>
            <param name="handler">The handler of the event to raise.</param>
            <param name="sender">The sender of the event.</param>
            <param name="arguments">The arguments to pass to the handler.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.Grouping`2">
            <summary>
            Class which implements the IGrouping interface to return grouped results in a query
            </summary>
            <typeparam name="TKey">type of the grouping key</typeparam>
            <typeparam name="TElement">type of the elements grouped</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.Grouping`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.Grouping`2"/> class.
            </summary>
            <param name="key">The key.</param>
            <param name="elements">The grouped elements.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.Grouping`2.System#Linq#IGrouping{TKey,TElement}#Key">
            <summary>
            Gets the key of the <see cref="T:System.Linq.IGrouping`2"/>.
            </summary>
            <returns>The key of the <see cref="T:System.Linq.IGrouping`2"/>.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.Grouping`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.Grouping`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2">
            <summary>
            Special commandified list which can create an index based on a key. 
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TKeyValue">The type of the key value.</typeparam>
            <remarks>This class can be a synchronized collection by passing true for isSynchronized in the constructor. To synchronize access to the contents of this class, 
            lock on the SyncRoot object. This class uses the same lock for its internal elements as the base class as these elements are related to the elements of the base class</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.#ctor(System.Func{`0,`1},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2"/> class.
            </summary>
            <param name="keyValueProducerFunc">The key value producer func.</param>
            <param name="keyPropertyName">Name of the key property which is used to track changes in individual elements.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.#ctor(System.Func{`0,`1},System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2"/> class.
            </summary>
            <param name="keyValueProducerFunc">The key value producer func.</param>
            <param name="keyPropertyName">Name of the key property which is used to track changes in individual elements.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.ContainsKey(`1)">
            <summary>
            Determines whether the specified key is present
            </summary>
            <param name="key">The key.</param>
            <returns><see langword="true"/> if the specified key is present, false otherwise. </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.FindByKey(`1)">
            <summary>
            Finds the instances which have the keyValue specified.
            </summary>
            <param name="keyValue">The key value.</param>
            <returns>an IEnumerable with all the elements which have the keyvalue specified or an empty enumerable if not found</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.FindFirstByKey(`1)">
            <summary>
            Helper method which returns the first element which matches the keyValue or null if not found.
            </summary>
            <param name="keyValue">The key value.</param>
            <returns>the first element which matches the keyValue or null if not found.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.OnAddingItem(`0)">
            <summary>
            Called right before the item passed in is about to be added to this list. Use this method to do event handler housekeeping on elements in this list.
            </summary>
            <param name="item">The item which is about to be added.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.OnClearing">
            <summary>
            Called right before the clear action starts. Use this method to do event handler housekeeping on elements in this list.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.OnRemovingItem(`0)">
            <summary>
            Called right before the item passed in is about to be removed from this list. Use this method to do event handler housekeeping on elements in this list.
            </summary>
            <param name="item">The item which is about to be removed.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.OnElementPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Called when the PropertyChanged event was raised by an element in this list.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.RemoveIndexOfElement(`0)">
            <summary>
            Removes the index of element.
            </summary>
            <param name="element">The element.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.KeyedCommandifiedList`2.IndexElement(`0)">
            <summary>
            Indexes the element.
            </summary>
            <param name="toIndex">To index.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1">
            <summary>
            Simple doubly linked list which doesn't suffer from the problem that one can't concat two linked lists in O(1). The .NET LinkedList class
            can't be used to fast connect two LinkedLists together without traversing all nodes of one of them (as each node has a reference to its containing list)
            </summary>
            <typeparam name="T">Type of contents in the buckets in this list</typeparam>
            <remarks>One could use the ListBucket class on its own as a raw linked list, however this class provides more utility code one will need
            anyway to use ListBucket instances in practise. If nodes are added to the linked list of buckets by using the ListBucket nodes themselves
            the count doesn't match, however doing so will also mess up the head/tail housekeeping references. So either use solely the buckets as a 
            linked list, or use this instance to manage the linked list of buckets</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.AppendTail(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Appends the specified bucket to the list, after the last element as a new tail.
            </summary>
            <param name="toAppend">To append.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.AppendTail(`0)">
            <summary>
            Appends the specified contents in a new bucket after the last element in the list as a new tail.
            </summary>
            <param name="contentsToAppend">The contents to append.</param>
            <returns>the bucket appended</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.InsertHead(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Inserts the specified bucket as the new head in the list.
            </summary>
            <param name="toInsert">To insert.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.InsertHead(`0)">
            <summary>
            Inserts the specified contents in a new bucket as the new head in the list.
            </summary>
            <param name="contentsToInsert">The contents to insert.</param>
            <returns>the bucket inserted</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.RemoveAfter(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Removes all buckets after the node specified. It assumes the specified node is in the ListBucketList. If it's not, all nodes in this list will
            be removed and the list will be empty.
            </summary>
            <param name="newTail">The new tail. Has to be in the list.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.RemoveBefore(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Removes all buckets before the node specified. It assumes the specified node is in the ListBucketList. If it's not, all nodes in this list will
            be removed and the list will be empty.
            </summary>
            <param name="newHead">The new head. Has to be in the list.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.InsertAfter(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0},SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Inserts the specified node toInsert after the node toInsertAfter.
            </summary>
            <param name="toInsert">To insert into the list.</param>
            <param name="toInsertAfter">the node to insert after. Has to be in the list</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.InsertBefore(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0},SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Inserts the specified node toInsert before the node toInsertBefore.
            </summary>
            <param name="toInsert">To insert into the list.</param>
            <param name="toInsertBefore">the node to insert before. Has to be in the list</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Remove(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Removes the specified bucket from the list.
            </summary>
            <param name="toRemove">To remove.</param>
            <remarks>Routine assumes the passed in bucket is in the linked bucket list managed by this instance</remarks>
            <returns>true if remove took place, otherwise false</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Remove(`0)">
            <summary>
            Removes the bucket with the specified contents from the list
            </summary>
            <param name="contentsToRemove">The contents to remove.</param>
            <returns>true if remove took place, otherwise false</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Remove(`0,System.Func{`0,`0,System.Boolean})">
            <summary>
            Removes the bucket with the specified contents from the list
            </summary>
            <param name="contentsToRemove">The contents to remove.</param>
            <param name="compareFunc">The compare func.</param>
            <returns>
            true if remove took place, otherwise false
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Concat(SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList{`0})">
            <summary>
            Concats the specified list after this list in an O(1) operation.
            </summary>
            <param name="toConcat">To concat.</param>
            <remarks>After the concat operation, the buckets in toConcat are referenced by this list. It's not recommended to keep on
            working with toConcat. Instead use this instance, as all data of toConcat is now part of this instance</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Find(`0)">
            <summary>
            Finds the bucket with the specified contents. 
            </summary>
            <param name="contents">The contents.</param>
            <returns>the bucket with the contents or null if not found.</returns>
            <remarks>Uses a linear search</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Find(`0,System.Func{`0,`0,System.Boolean})">
            <summary>
            Finds the bucket with the specified contents using the comparer func specified.
            </summary>
            <param name="contents">The contents.</param>
            <param name="compareFunc">The compare func.</param>
            <returns>
            the bucket with the contents or null if not found.
            </returns>
            <remarks>Uses a linear search</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Clear">
            <summary>
            Clears this instance. It doesn't reset the individual nodes, it just cuts off references to head and tail so the list contents goes
            out of scope.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Head">
            <summary>
            Gets the head of the list
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Tail">
            <summary>
            Gets the tail of the list.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.LinkedBucketList`1.Count">
            <summary>
            Gets the number of elements in this list. 
            </summary>
            <remarks>This is the number calculated from append/insert/remove actions.</remarks>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1">
            <summary>
            Simple class which can be used as a bucket in a linked list. The .NET LinkedList class has a downside that you can't concatenate two
            linked lists in O(1) time: a LinkedListNode is part of a LinkedList object and to connect two lists, one has to traverse one of them in full.
            </summary>
            <typeparam name="T">Type of the element contained in this bucket</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1"/> class.
            </summary>
            <param name="contents">The contents.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.AppendAfter(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Appends the passed in bucket after this bucket in the list.
            </summary>
            <param name="toAppend">To append.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.AppendAfter(`0)">
            <summary>
            Appends the passed in contents in a new bucket after this bucket in the list.
            </summary>
            <param name="toAppendContents">The contents of the bucket to append.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.InsertBefore(SD.Tools.Algorithmia.GeneralDataStructures.ListBucket{`0})">
            <summary>
            Inserts the passed in bucket before this bucket in the list
            </summary>
            <param name="toInsert">To insert.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.InsertBefore(`0)">
            <summary>
            Inserts the passed in contents in a new bucket before this bucket in the list
            </summary>
            <param name="toInsertContents">The contents of the new bucket to insert.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.RemoveFromList">
            <summary>
            Removes this bucket from the list, connecting both ends together.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.Contents">
            <summary>
            Gets or sets the contents of this bucket
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.Next">
            <summary>
            Gets or sets the next bucket in the list
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ListBucket`1.Previous">
            <summary>
            Gets or sets the previous bucket in the list.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2">
            <summary>
            Extension to the normal Dictionary. This class can store more than one value for every key. It keeps a HashSet for every Key value.
            Calling Add with the same Key and multiple values will store each value under the same Key in the Dictionary. Obtaining the values
            for a Key will return the HashSet with the Values of the Key. It can also merge with other instances of MultiValueDictionary, as long
            as the TKey and TValue types are equal.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2"/> class.
            </summary>
            <param name="valueComparer">The IEqualityComparer&lt;TValue&gt; which is used for the HashSet objects created for each TKey instance. 
            Can be null, in which case the default EqualityComparer is used.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2"/> class.
            </summary>
            <param name="info">The info.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.Clone">
            <summary>
            Clones this instance using shallow copy
            </summary>
            <returns></returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the object data.
            </summary>
            <param name="info">The info.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.Add(`0,`1)">
            <summary>
            Adds the specified value under the specified key
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.AddRange(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Adds the range of values under the key specified.
            </summary>
            <param name="key">The key.</param>
            <param name="values">The values.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.ContainsValue(`0,`1)">
            <summary>
            Determines whether this dictionary contains the specified value for the specified key 
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>true if the value is stored for the specified key in this dictionary, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.Remove(`0,`1)">
            <summary>
            Removes the specified value for the specified key. It will leave the key in the dictionary.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.Merge(SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary{`0,`1})">
            <summary>
            Merges the specified multivaluedictionary into this instance.
            </summary>
            <param name="toMergeWith">To merge with.</param>
            <remarks>If this instance has an EqualityComparer set for the values, it is used when merging toMergeWith</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.MultiValueDictionary`2.GetValues(`0,System.Boolean)">
            <summary>
            Gets the values for the key specified. This method is useful if you want to avoid an exception for key value retrieval and you can't use TryGetValue
            (e.g. in lambdas)
            </summary>
            <param name="key">The key.</param>
            <param name="returnEmptySet">if set to true and the key isn't found, an empty hashset is returned, otherwise, if the key isn't found, null is returned</param>
            <returns>
            This method will return null (or an empty set if returnEmptySet is true) if the key wasn't found, or
            the values if key was found.
            </returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1">
            <summary>
            Special version of the bindinglist, where the generic elements have to implement IEventBasedObserver to get their events managed.
            </summary>
            <typeparam name="T">Type of the element contained in this special binding list.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1"/> class.
            </summary>
            <param name="elements">The elements.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the range.
            </summary>
            <param name="rangeToAdd">The range to add.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.SetItem(System.Int32,`0)">
            <summary>
            Replaces the item at the specified index with the specified item.
            </summary>
            <param name="index">The zero-based index of the item to replace.</param>
            <param name="item">The new value for the item at the specified index. The value can be null for reference types.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	<paramref name="index"/> is less than zero.
            -or-
            <paramref name="index"/> is greater than <see cref="P:System.Collections.ObjectModel.Collection`1.Count"/>.
            </exception>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.InsertItem(System.Int32,`0)">
            <summary>
            Inserts the specified item in the list at the specified index.
            </summary>
            <param name="index">The zero-based index where the item is to be inserted.</param>
            <param name="item">The item to insert in the list.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.ClearItems">
            <summary>
            Removes all elements from the collection.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.RemoveItem(System.Int32)">
            <summary>
            Removes the item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException">
            You are removing a newly added item and <see cref="P:System.ComponentModel.IBindingList.AllowRemove"/> is set to false.
            </exception>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.UnbindFromNotifyElementRemoved(`0)">
            <summary>
            Unbinds the eventhandler from item.ElementRemoved if item implements INotifyElementRemoved
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.BindToNotifyElementRemoved(`0)">
            <summary>
            Binds the eventhandler to item.ElementRemoved if item implements INotifyElementRemoved
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ObserverAwareBindingList`1.element_ElementRemoved(System.Object,System.EventArgs)">
            <summary>
            Handles the ElementRemoved event of the element control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2">
            <summary>
            Simple class which represents a pair of values which can be of different types. It's not a struct so it can be modified in-place inside
            other constructs.
            </summary>
            <typeparam name="TVal1">The type of value 1.</typeparam>
            <typeparam name="TVal2">The type of value 2.</typeparam>
            <remarks>Pair implements Equals and GetHashCode. The implementation is oriented towards C# null behavior (null==null is true), so if you're using 
            VB.NET, you've to take this into account.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2"/> class.
            </summary>
            <param name="value1">The value for Value1.</param>
            <param name="value2">The value for Value2.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
            <remarks>null == null is considered true. If TVal1 or TVal2 is an array type, the values are considered equal if the values in the array are
            equal</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2.GetHashCode">
            <summary>
            Returns the hashcode of this instance. 
            </summary>
            <returns>
            The XOR result of the hashcode of Value1 and Value2. If one of the values is null, that value is ignored. If both are null, the hashcode of this instance
            is returned. 
            </returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2.Value1">
            <summary>
            Gets or sets Value1.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2.Value2">
            <summary>
            Gets or sets Value2.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralDataStructures.ReadOnlyPair`2">
            <summary>
            Simple class which represents a pair of values which can be of different types, and which is readonly. 
            </summary>
            <typeparam name="TVal1">The type of value 1.</typeparam>
            <typeparam name="TVal2">The type of value 2.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralDataStructures.ReadOnlyPair`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.GeneralDataStructures.Pair`2"/> class.
            </summary>
            <param name="value1">The value for Value1.</param>
            <param name="value2">The value for Value2.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ReadOnlyPair`2.Value1">
            <summary>
            Gets Value1.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.GeneralDataStructures.ReadOnlyPair`2.Value2">
            <summary>
            Gets Value2.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralInterfaces.IDetailedNotifyElementChanged`2">
            <summary>
            Interface for raising a detailed event containing the change notification about what has changed in the element. CommandifiedList picks up these
            events and bubbles upwards this event to subscribers. 
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralInterfaces.IDetailedNotifyElementChanged`2.DetailedElementChanged">
            <summary>
            Raised when the implementing object's data changed. What has changed is enclosed in the event arguments. Similar event as INotifyElementChanged.ElementChanged
            however this variant has detailed information about which change took place.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralInterfaces.IEventBasedObserver">
            <summary>
            Simple interface which is used by elements which require support from external code to get their internal observer logic be setup. This is required
            sometimes in undo-redo scenarios where an element is added/removed from a datastructure, e.g. a list. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralInterfaces.IEventBasedObserver.BindEvents">
            <summary>
            Binds the event handlers inside the implementing object.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.GeneralInterfaces.IEventBasedObserver.UnbindEvents">
            <summary>
            Unbinds the event handlers inside the implementing object.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralInterfaces.INotifyAsChanged">
            <summary>
            Simple notification interface which is used to signal elements which refer to other elements that the implementing element has been changed.
            The type/nature of the change isn't available, as other channels are meant for that, this notification is a simple 'I'm changed' kind of 
            notification used by CommandifiedMember.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralInterfaces.INotifyAsChanged.HasBeenChanged">
            <summary>
            Raised when the implementing element has been changed
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.GeneralInterfaces.INotifyAsRemoved">
            <summary>
            Simple notification interface which is used to signal elements which refer to other elements that the implementing element has been removed.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.GeneralInterfaces.INotifyAsRemoved.HasBeenRemoved">
            <summary>
            Raised when the implementing element has been removed from its container
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2">
            <summary>
            Finder which produces per disconnected subgraph a SubGraphView instance with all the vertices and edges of the disconnected graph. 
            </summary>
            <typeparam name="TVertex">Type of the vertices in the graph to crawl</typeparam>
            <typeparam name="TEdge">Type of the edges in the graph to crawl</typeparam>
            <remarks>Only use this on a non-directed graph. Using this algorithm on a directed graph will give an InvalidOperationException as it doesn't lead to 
            satisfying results</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.#ctor(System.Func{SD.Tools.Algorithmia.Graphs.SubGraphView{`0,`1}},SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2"/> class.
            </summary>
            <param name="subGraphViewCreatorFunc">The sub graph view creator func, used to create new subgraphview instances.</param>
            <param name="toCrawl">the graph to crawl</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.FindDisconnectedGraphs">
            <summary>
            Finds the disconnected graphs.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.FindDisconnectedGraphs(`0,System.Boolean)">
            <summary>
            Finds the disconnected graphs.
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="onlyDisconnectedGraphOfStartVertex">if set to true, the finder will only determine the disconnected graph of the startvertex and
            stop after a new disconnected graph is detected</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.RootDetected(`0)">
            <summary>
            Signal the detection of a root vertex that has been visited by the crawler.
            </summary>
            <param name="vertexVisited">The detected root vertex</param>
            <remarks>Only called in non-directed graphs, as root detection isn't possible with a DFS crawler in directed graphs without additional algorithm code</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.OnVisiting(`0,System.Collections.Generic.HashSet{`1})">
            <summary>
            Called when the vertexToVisit is about to be visited over the edges specified. This method is called right before all vertices related to vertexToVisit
            are visited.
            </summary>
            <param name="vertexVisited">The vertex currently visited</param>
            <param name="edges">The edges usable to visit vertexToVisit. Can be null, in which case the vertex was visited without using an edge (which would mean
            the vertex is a tree root, or the start vertex.)</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.NewDisconnectedGraphFound">
            <summary>
            A new Disconnected graph was found and this routine updates internal datastructures.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.InitClass(System.Boolean)">
            <summary>
            Inits the class.
            </summary>
            <param name="stopAfterFirstSubGraph">if set to <see langword="true"/> [stop after first sub graph].</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.ObtainEdges">
            <summary>
            Obtains the edges for each found subgraph from the main graph. Called after a crawl has finished. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.Algorithms.DisconnectedGraphsFinder`2.FoundDisconnectedGraphs">
            <summary>
            Gets the disconnected graphs found;
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.Algorithms.RootDetector`2">
            <summary>
            DepthFirstSearchCrawler implementation to detect the number of roots ( disconnected subgraphs) within a non-directed graph, which helps identifing a 
            disconnected graph.        
            </summary>
            <typeparam name="TVertex">Type of the vertex of the graph to crawl</typeparam>
            <typeparam name="TEdge">Type of the edge of the graph to crawl</typeparam>
            <remarks>Graph has to be undirected. Directed graphs could give more roots than there really are, which is the reason that using this algorithm on a
            directed graph results in an InvalidOperationException.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.RootDetector`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1})">
            <summary>
            CTor
            </summary>
            <param name="toCrawl"></param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.RootDetector`2.SearchForRoots">
            <summary>
            Searches for roots within the graph
            </summary>
            <returns>number of roots detected, 1 signifies a connected graph, more than 1 signifies a disconnected graph</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.RootDetector`2.RootDetected(`0)">
            <summary>
            Signal the detection of a root vertex that has been visited by the crawler.
            </summary>
            <param name="vertexVisited">The detected root vertex</param>
            <remarks>Only called in non-directed graphs, as root detection isn't possible with a DFS crawler in directed graphs without additional algorithm code</remarks>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.Algorithms.RootDetector`2.RootsFound">
            <summary>
            Gets the roots found.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2">
            <summary>
            Implementation of the Topological Sort algorithm for directed graphs. Topological sorting is a way to determine which vertex is relying on which vertices
            so it has to be processed first. Topological sorting relies on Depth first search (Tarjan 1976: http://www.springerlink.com/content/k5633403j221763p/)
            The algorithm implementation here has two choices for direction interpretation, which is controlled by a flag passed to the constructor: if the directed
            edge A to B means A has to be done before B, pass true for the flag <i>directionMeansOrder</i>, otherwise false. Default is false (A to B means A is depending on
            B, so B should be done before A).
            See for more information: http://en.wikipedia.org/wiki/Topological_sorting
            </summary>
            <typeparam name="TVertex">The type of the vertex.</typeparam>
            <typeparam name="TEdge">The type of the edge.</typeparam>
            <remarks>By definition topological sorting isn't possible on directed graphs which have at least one cycle (A->B->C->A->D). This algorithm will throw
            an InvalidOperationException exception if it detects a cycle.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2"/> class.
            </summary>
            <param name="graphToCrawl">The directed graph to crawl.</param>
            <remarks>Assumes a directed edge from A to B means A is depending on B and therefore B should be placed before A</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2"/> class.
            </summary>
            <param name="graphToCrawl">The directed graph to crawl.</param>
            <param name="directionMeansOrder">If set to true, a directed edge from A to B is interpreted as the order in which A and B should be done, i.e. first A
            then B. When false is passed (default) the edge from A to B is interpreted as A is depending on B and therefore B should be done before A.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2.Sort">
            <summary>
            Runs the algorithm on the graph passed to the constructor
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2.CycleDetected(`0,System.Collections.Generic.HashSet{`1})">
            <summary>
            A cycle has been detected in a directed graph. This method is called to signal derived classes that the cycle has been detected, as the derived class
            ordered this class to signal it if cycles were detected. Cycle checks are only performed on directed graphs.
            </summary>
            <param name="relatedVertex">The related vertex which formed the cycle.</param>
            <param name="edges">The edges used to visit the related vertex.</param>
            <returns>
            true if routines should proceed deeper into the graph, false otherwise (so traversing will stop at this point and backtrack with
            other paths). Returning true could lead to infinite loops. Default is true
            </returns>
            <remarks>It's recommended you throw an exception to quit the operation entirely if your algorithm can't deal with cycles.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2.OnVisited(`0,System.Collections.Generic.HashSet{`1})">
            <summary>
            Called when the vertexVisited was visited over the edges specified. This method is called right after all vertices related to vertexVisited were visited.
            </summary>
            <param name="vertexVisited">The vertex visited right before this method.</param>
            <param name="edges">The edges usable to visit vertexVisited. Can be null, in which case the vertex was visited without using an edge (which would mean
            the vertex is a tree root, or the start vertex.)</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2.SortResults">
            <summary>
            Gets or sets the sort results. This is one possible correct topological order of the graph passed into the constructor. Topological sorting doesn't guarantee
            that there is just 1 ordering, there can be many correct orderings. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.Algorithms.TopologicalSorter`2.SeeCycleCreatingEdgesAsNonExistend">
            <summary>
            Gets or sets a value indicating whether edges which create a cycle should be seen as real (true) or as edges which can be ignored and
            have no influence on the outcome (false, default). 'False' means that an exception is thrown when a cycle is detected. 
            True means that the traversal is broken off at the re-visited vertex and continued using backtracking. Leave this property to false, 
            unless cycles should be allowed.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2">
            <summary>
            Basic crawler class which crawls over all vertices in the graph it is set to crawl. For every visited vertex, it will call a visit routine, which can be
            overriden in derived classes. Depth first search is discussed here: http://en.wikipedia.org/wiki/Depth_first_search and it's the base for many graph known
            algorithms. An alternative is breadth first search, which uses a method which is non-recursive.
            </summary>
            <typeparam name="TVertex">The type of vertices</typeparam>
            <typeparam name="TEdge">The type of the edges in the graph</typeparam>
            <remarks>This class has no public methods, as it's meant to be a mechanism for algorithm implementation to consume a graph in a given order</remarks>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.VertexColor">
            <summary>
            Enum for marking vertices along the way. For cycle detection
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.VertexColor.NotVisited">
            <summary>
            Vertex hasn't been visited yet
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.VertexColor.Visiting">
            <summary>
            Vertex is in the process of being visited. As this algorithm is recusive, if we run into a vertex which has this color, we ran into a cycle
            </summary>
        </member>
        <member name="F:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.VertexColor.Visited">
            <summary>
            Vertex was completely visited.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2"/> class.
            </summary>
            <param name="graphToCrawl">The graph to crawl.</param>
            <param name="detectCycles">if set to true, the crawler will notify derived classes that a cycle has been detected if the graph to crawl is a 
            directed graph, as cycles in directed graphs influence algorithms which work with directed graphs.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.Crawl">
            <summary>
            Crawls the graph set as the graphToCrawl in the constructor. It picks the first vertex in the graph to start.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.Crawl(`0)">
            <summary>
            Crawls the graph set as the graphToCrawl in the constructor, starting with the vertex specified. If the vertex isn't in the graph, the routine is a no-op
            </summary>
            <param name="vertexToStart">The vertex to start the crawl operation.</param>
            <remarks>vertexToStart can't be null, as a graph can't contain null vertices</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.RootDetected(`0)">
            <summary>
            Signal the detection of a root vertex that has been visited by the crawler.
            </summary>
            <param name="vertex">The detected root vertex</param>
            <remarks>Only called in non-directed graphs, as root detection isn't possible with a DFS crawler in directed graphs without additional algorithm code</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.CycleDetected(`0,System.Collections.Generic.HashSet{`1})">
            <summary>
            A cycle has been detected in a directed graph. This method is called to signal derived classes that the cycle has been detected, as the derived class
            ordered this class to signal it if cycles were detected. Cycle checks are only performed on directed graphs.
            </summary>
            <param name="relatedVertex">The related vertex which formed the cycle.</param>
            <param name="edges">The edges used to visit the related vertex.</param>
            <returns>true if routines should proceed deeper into the graph, false otherwise (so traversing will stop at this point and backtrack with
            other paths). Returning true could lead to infinite loops. Default is false</returns>
            <remarks>It's recommended you throw an exception to quit the operation entirely if your algorithm can't deal with cycles.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.OnVisiting(`0,System.Collections.Generic.HashSet{`1})">
            <summary>
            Called when the vertexToVisit is about to be visited over the edges specified. This method is called right before all vertices related to vertexToVisit
            are visited.
            </summary>
            <param name="vertexVisited">The vertex currently visited</param>
            <param name="edges">The edges usable to visit vertexToVisit. Can be null, in which case the vertex was visited without using an edge (which would mean
            the vertex is a tree root, or the start vertex.)</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.OnVisited(`0,System.Collections.Generic.HashSet{`1})">
            <summary>
            Called when the vertexVisited was visited over the edges specified. This method is called right after all vertices related to vertexVisited were visited.
            </summary>
            <param name="vertexVisited">The vertex visited right before this method.</param>
            <param name="edges">The edges usable to visit vertexVisited. Can be null, in which case the vertex was visited without using an edge (which would mean
            the vertex is a tree root, or the start vertex.)</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.Visit(`0,System.Collections.Generic.IDictionary{`0,SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler{`0,`1}.VertexColor},System.Collections.Generic.HashSet{`1})">
            <summary>
            The actual crawler routine. It visits the specified vertex over the edge used. If the vertex is visitable over multiple edges from the last visited vertex,
            the routine is called multiple times. 
            </summary>
            <param name="vertex">The vertex.</param>
            <param name="verticesProcessed">The vertices processed.</param>
            <param name="edges">The edges usable to visit the vertex.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.DepthFirstSearchCrawler`2.AbortCrawl">
            <summary>
            Sets the abortCrawl flag which will abort the crawl of the graph. 
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.DirectedEdge`1">
            <summary>
            Class which represents a directed edge in a graph. A directed edge from A to B means A has a connection with B
            but B doesn't have a connection with A.
            </summary>
            <typeparam name="TVertex">The type of the vertices in this edge.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedEdge`1.#ctor(`0,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedEdge`1"/> class.
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedEdge`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2">
            <summary>
            Basic class which simply makes the graph base act like a directed graph. 
            </summary>
            <typeparam name="TVertex">The type of the vertex.</typeparam>
            <typeparam name="TEdge">The type of the information inside the edge.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(System.Func{`0,`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(System.Func{`0,`0,`1},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(System.Func{`0,`0,`1},System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.DirectedGraph{`0,`1})">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.DirectedGraph{`0,`1},System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.DirectedGraph{`0,`1},System.Func{`0,`0,`1})">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.DirectedGraph{`0,`1},System.Func{`0,`0,`1},System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.DirectedGraph{`0,`1},System.Func{`0,`0,`1},System.Boolean,System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.DirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.DirectedGraph`2.TransitiveClosure">
            <summary>
            Returns the transitive closure of this graph using the Floyd-Warshall algorithm.
            See http://en.wikipedia.org/wiki/Transitive_closure and http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm.
            </summary>
            <returns>The transitive closure of this graph.</returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.Edge`1">
            <summary>
            Class which represents an edge in a graph. It can be used for directed and non-directed edges. A directed edge from A to B means A has a connection with B
            but B doesn't have a connection with A.
            </summary>
            <typeparam name="TVertex">The type of the vertices in this edge.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Edge`1.#ctor(`0,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.Edge`1"/> class.
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
            <remarks>Creates a directed (from startVertex to endVertex) edge</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.Edge`1.#ctor(`0,`0,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.Edge`1"/> class.
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
            <param name="isDirected">if set to true, this edge is considered a directed edge, from startVertex to endVertex</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.Edge`1.StartVertex">
            <summary>
            Gets the start vertex of the edge.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.Edge`1.EndVertex">
            <summary>
            Gets the end vertex of the edge.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.Edge`1.IsDirected">
            <summary>
            Gets a value indicating whether this edge is directed. If true, the edge is directed from startVertex to endVertex and is seen as an edge only between
            startVertex and endVertex, not between endVertex and startVertex. If false, this edge isn't considered a directed edge and is seen as an edge between
            startVertex and endVertex and also between endVertex and startVertex.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.GraphBase`2">
            <summary>
            abstract base class for graphs. It can handle non-directed and directed graphs. A directed edge from A to B means that A has a connection with B, but
            B doesn't have a connection with A.
            </summary>
            <typeparam name="TVertex">The type of the vertices in this graph.</typeparam>
            <typeparam name="TEdge">The type of the edges in the graph</typeparam>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.GraphBase`2.GraphCommandType">
            <summary>
            Enum for finding back command descriptions. These descriptions are cached because they'd otherwise overflow the GC memory with string fragments
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.VertexAdded">
            <summary>
            Event which is raised when a vertex has been added
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.VertexRemoved">
            <summary>
            Event which is raised when a vertex has been removed
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.EdgeAdded">
            <summary>
            Event which is raised when an edge has been added
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.EdgeRemoved">
            <summary>
            Event which is raised when an edge has been removed
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.VertexAdding">
            <summary>
            Event which is raised when a vertex is about to be added.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.VertexRemoving">
            <summary>
            Event which is raised when a vertex is about to be removed
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.EdgeAdding">
            <summary>
            Event which is raised when an edge is about to be added
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.GraphBase`2.EdgeRemoving">
            <summary>
            Event which is raised when an edge is about to be removed
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.GraphBase`2"/> class.
            </summary>
            <param name="isDirected">if set to true, the graph is directed and only edges which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and edges which have IsDirected set to false are accepted.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.GraphBase`2"/> class.
            </summary>
            <param name="isDirected">if set to true, the graph is directed and only edges which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and edges which have IsDirected set to false are accepted.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.GraphBase`2"/> class.
            </summary>
            <param name="isDirected">if set to true, the graph is directed and only edges which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and edges which have IsDirected set to false are accepted.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.GraphBase`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="isDirected">if set to true, the graph is directed and only edges which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and edges which have IsDirected set to false are accepted.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean,System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.GraphBase`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="isDirected">if set to true, the graph is directed and only edges which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and edges which have IsDirected set to false are accepted.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.GraphBase`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="isDirected">if set to true, the graph is directed and only edges which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and edges which have IsDirected set to false are accepted.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetVerticesSyncedAsList">
            <summary>
            Gets the vertices as list, and perform this operation synced with the SyncRoot, to avoid threading issues.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetEdgesSyncedAsList">
            <summary>
            Gets the edges as list, and perform this operation synced with the SyncRoot, to avoid threading issues.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Add(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1})">
            <summary>
            Adds all elements (i.e. vertices and edges) from the provided graph to this graph.
            </summary>
            <param name="graph">The graph to add all elements (i.e. vertices and edges) from to this graph.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Add(`1)">
            <summary>
            Adds the provided edge to this graph. If the vertex(s) are not yet in this graph, it/they are added as well.
            </summary>
            <param name="edge">The edge to add to this graph. </param>
            <remarks>The edge has to be compatible with this graph: the edge has to be a directed edge if this graph is a directed graph and vice versa.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Add(`0)">
            <summary>
            Adds the provided vertex to this graph.
            </summary>
            <param name="vertex">The vertex to add to this graph.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Remove(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1})">
            <summary>
            Removes all elements (i.e. vertices and edges) of the provided graph from this graph.
            </summary>
            <param name="graph">The graph to remove all elements (i.e. vertices and edges) of from this graph.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Remove(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean)">
            <summary>
            Removes all elements (i.e. vertices and/or edges) of the provided graph from this graph.
            </summary>
            <param name="graph">The graph to remove all elements (i.e. vertices and edges) of from this graph.</param>
            <param name="edgesOnly">if set to true, only the edges are removed, otherwise edges and vertices</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Remove(`1)">
            <summary>
            Removes the provided edge from the graph.
            </summary>
            <param name="edge">The edge to remove.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Remove(`0)">
            <summary>
            Removes a vertex from this graph.
            </summary>
            <param name="vertex">The vertex to remove from this graph.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Disconnect(`0,`0,System.Boolean)">
            <summary>
            Removes all edges from this graph between startVertex and endVertex. It will only remove edges between startVertex and endVertex, not between endVertex and startVertex,
            unless bothSides is set to true, then all edges between both vertices are removed, discarding their direction.
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
            <param name="bothSides">if set to true, the edges owned by both sides are removed, otherwise only the edges from startVertex to endVertex</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.ContainsEdge(`0,`0)">
            <summary>
            Returns whether an edge exists in this graph between the start vertex and the end vertex specified. 
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
            <returns>
            True if there is an edge in this graph from startVertex to endVertex. False otherwise.
            </returns>
            <remarks>If this graph is a directed graph, it will return false if there is an edge between endVertex and startVertex but not between startVertex and endVertex</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Contains(`1)">
            <summary>
            Determines whether this graph contains the edge object specified. 
            </summary>
            <param name="edge">The edge.</param>
            <returns>true if the edge object is present. False otherwise. Also returns false if there is an edge between the start/end vertices of the edge specified
            but the edge object known to this graph is different from the edge specified. 
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Contains(`0)">
            <summary>
            Returns whether a vertex exists in this graph.
            </summary>
            <param name="vertex">The vertex whose inclusion must be checked.</param>
            <returns>True if the provided vertex exists in this graph. False otherwise.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetEdges(`0,`0)">
            <summary>
            Gets all the edges between startVertex and endVertex.
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
            <returns>Set of edges between startVertex and endVertex or an empty set if one or both vertices aren't part of this graph or there are no edges.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetAdjacencyListForVertex(`0)">
            <summary>
            Gets the adjacency list for vertex. The adjacency list is a list of TVertex - Hashset(Of TEdge) tuples, as a vertex can have multiple edges with the same
            related vertex.
            </summary>
            <param name="vertex">The vertex to obtain the adjacency list for.</param>
            <returns>MultiValueDictionary with as key the related vertices of the passed in vertex and as value per related vertex a Hashset with edges which 
            connect passed in vertex with the related vertex, or null if the vertex isn't part of this graph</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetEdgesFromStartVertex(`0)">
            <summary>
            Gets all the edges started from the startvertex specified.
            </summary>
            <param name="startVertex">The start vertex of the edges to obtain.</param>
            <returns>Set of edges starting from startVertex or an empty set if startVertex isn't part of this graph</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetEdgesToEndVertex(`0)">
            <summary>
            Gets all the edges which end in the endVertex specified.
            </summary>
            <param name="endVertex">The end vertex of the edges to obtain.</param>
            <returns>Set of edges which have the specified endVertex as their endVertex, or an empty set if endVertex isn't part of this graph</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetOrphanedVertices">
            <summary>
            Gets the orphaned vertices. Orphaned vertices are vertices which are not part of any edge in the graph
            </summary>
            <returns>Set of vertices which aren't part of any edge in the graph</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetSubGraph``1(System.Func{`0,System.Boolean},System.Func{`1,System.Boolean})">
            <summary>
            Gets a subgraph from this graph with the vertices and edges which match the functions specified. It creates a new instance and 
            places the same vertex and edge instances in that graph. 
            </summary>
            <typeparam name="TGraph">The type of the graph.</typeparam>
            <param name="vertexSelector">The vertex selector. Can be null, which will result in all vertices being added</param>
            <param name="edgeSelector">The edge selector. Can be null, which will result in all edges being added</param>
            <returns>New graph instance with all vertices and edges from this graph which match the selector function specified</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Compose``1(``0,``0,System.Func{`0,`0,`1})">
            <summary>
            Returns a composition of the two provided graphs. See http://en.wikipedia.org/wiki/Lexicographic_product_of_graphs.
            </summary>
            <typeparam name="TGraph">The type of the graph.</typeparam>
            <param name="g">The first graph to compose.</param>
            <param name="h">The second graph to compose.</param>
            <param name="edgeProducerFunc">The edge producer func, which is used to produce edges for the graph to return.</param>
            <returns>
            The graph composition (lexicographic product) of the two provided graphs.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.IsConnected">
            <summary>
            A graph is called connected if every pair of distinct vertices in the graph is connected (directly or indirectly). 
            A connected component is a maximal connected subgraph of G. Each vertex belongs to exactly one connected component, as does each edge.
            A directed graph is called weakly connected if replacing all of its directed edges with undirected edges produces a connected (undirected) graph. 
            It is strongly connected or strong if it contains a directed path from u to v and a directed path from v to u for every pair of vertices u,v. 
            The strong components are the maximal strongly connected subgraphs.
            See http://en.wikipedia.org/wiki/Connectivity_(graph_theory)
            
            We will only check for a connected un-directed graph or a weakly connected directed graph (same logic).
            </summary>
            <returns>True if the graph is considered connected, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.GetAsNonDirectedCopy">
            <summary>
            Creates a NonDirectedGraph version of this graph. Always creates a copy, even if this graph is a non-directed graph.
            </summary>
            <returns>this graph as a nondirected copy, even if this graph is a non-directed graph</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.ValidateEdgeForAddition(`1,`0,`0)">
            <summary>
            Validates if the edge passed in is addable to this graph structure. The start vertex and the end vertex for the are given as well. The same edge
            is present between startVertex and endVertex and also between endVertex and startVertex if the graph is a nondirected graph, hence the necessity of these two
            vertices in this routine
            </summary>
            <param name="edgeToAdd">The edge to validate.</param>
            <param name="startVertex">The start vertex the edge is starting from.</param>
            <param name="endVertex">The end vertex the edge is leading to.</param>
            <returns>true if the edge can be added, false otherwise. Returning false results in the edge not being added</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.ValidateVertexForAddition(`0)">
            <summary>
            Validates if the vertex passed in is addable to this graph structure.
            </summary>
            <param name="vertexToAdd">The vertex to validate.</param>
            <returns>true if the vertex can be added, false otherwise. Returning false results in the vertex not being added</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.ValidateEdgeForRemoval(`1,`0,`0)">
            <summary>
            Validates if the edge passed in is removable from this graph structure. The start vertex and the end vertex for the are given as well. The same edge
            is present between startVertex and endVertex and also between endVertex and startVertex if the graph is a nondirected graph, hence the necessity of these two
            vertices in this routine
            </summary>
            <param name="edgeToRemove">The edge to remove.</param>
            <param name="startVertex">The start vertex the edge is starting from.</param>
            <param name="endVertex">The end vertex the edge is leading to.</param>
            <returns>true if the edge can be removed, false otherwise. Returning false results in the edge not being removed</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.ValidateVertexForRemoval(`0)">
            <summary>
            Validates if the vertex passed in is removable from this graph structure. 
            </summary>
            <param name="vertexToRemove">The vertex to remove.</param>
            <returns>true if the vertex can be removed, false otherwise. Returning false results in the vertex not being removed</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.ValidateVertexFromRemovalFromAdjacencyList(`0,`0)">
            <summary>
            Validates if the vertexToRemove passed in is removable from the adjacency list of the vertex <i>vertex</i>. Removing the vertex means all edges from vertex to
            vertexToRemove are physically removed from the graph structure.
            </summary>
            <param name="vertexToRemove">The vertex to remove from the adjacency list.</param>
            <param name="vertex">The vertex which owns the adjacency list.</param>
            <returns></returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformSyncedAction(System.Action)">
            <summary>
            Performs the specified action, either inside a lock on <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> if this graph is Synchronized, or normally, if the graph isn't synchronized.
            </summary>
            <param name="toPerform">To perform.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformSyncedAction``1(System.Func{``0})">
            <summary>
            Performs the specified action, either inside a lock on <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> if this graph is Synchronized, or normally, if the graph isn't synchronized.
            </summary>
            <typeparam name="T">The type of the element to return</typeparam>
            <param name="toPerform">To perform.</param>
            <returns>the result of toPerform</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnVertexAdded(`0)">
            <summary>
            Called when a vertex has been added
            </summary>
            <param name="vertexAdded">The vertex added.</param>
            <remarks>Raises VertexAdded</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnVertexRemoved(`0)">
            <summary>
            Called when a vertex has been removed
            </summary>
            <param name="vertexRemoved">The vertex removed.</param>
            <remarks>Raises VertexRemoved</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnEdgeAdded(`1)">
            <summary>
            Called when an edge has been added
            </summary>
            <param name="edgeAdded">The edge added.</param>
            <remarks>Raises EdgeAdded</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnEdgeRemoved(`1)">
            <summary>
            Called when an edge has been removed
            </summary>
            <param name="edgeRemoved">The edge removed.</param>
            <remarks>Raises EdgeRemoved</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnVertexAdding(`0)">
            <summary>
            Called when a vertex is about to be added
            </summary>
            <param name="vertexToBeAdded">The vertex to be added.</param>
            <remarks>Raises VertexAdding</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnVertexRemoving(`0)">
            <summary>
            Called when a vertex is about to be removed
            </summary>
            <param name="vertexToBeRemoved">The vertex to be removed.</param>
            <remarks>Raises VertexRemoving</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnEdgeAdding(`1)">
            <summary>
            Called when an edge is about to be added
            </summary>
            <param name="edgeToBeAdded">The edge to be added.</param>
            <remarks>Raises EdgeAdding</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.OnEdgeRemoving(`1)">
            <summary>
            Called when an edge is about to be removed
            </summary>
            <param name="edgeToBeRemoved">The edge to be removed.</param>
            <remarks>Raises EdgeRemoving</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.Initialize(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Initializes this instance.
            </summary>
            <param name="isDirected">if set to true, the graph is directed and only EdgeBase instances which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and EdgeBase instances which have IsDirected set to false are accepted.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.BuildCachedCommandDescriptions">
            <summary>
            Builds the cached command descriptions.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.CheckIfPartOfGraph(`0,System.String)">
            <summary>
            Checks if the vertex is part of the graph. If not it will throw an ArgumentException that the argument with the passed in name isn't part of the graph
            </summary>
            <param name="vertex">The vertex.</param>
            <param name="argumentName">Name of the argument.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.CheckEdge(`1)">
            <summary>
            Checks the edge if it's an edge which can be part of this graph. This depends on the fact if the edge's IsDirected flag is the same as this graph's
            IsDirected flag. If the edge isn't compatible, an argumentexception is raised. 
            </summary>
            <param name="edge">The edge.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformAddGraph(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1})">
            <summary>
            Performs the add action for adding a complete graph to this graph.
            </summary>
            <param name="graph">The graph.</param>
            <remarks>If you want to undo actions performed by this method, call this method using a Command object.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformRemoveGraph(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean)">
            <summary>
            Performs the remove action for removing a complete graph from this graph.
            </summary>
            <param name="graphToRemove">The graph to remove all elements (i.e. vertices and edges) of from this graph.</param>
            <param name="edgesOnly">if set to true, only the edges are removed, otherwise edges and vertices</param>
            <remarks>If you want to undo actions performed by this method, call this method using a Command object.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformRemoveEdge(`1)">
            <summary>
            Performs the remove action for an edge from this graph
            </summary>
            <param name="edgeToRemove">The edge to remove.</param>
            <remarks>If you want to undo actions performed by this method, call this method using a Command object.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformAddVertex(`0)">
            <summary>
            Performs the Add action for a vertex to the adjacency lists.
            </summary>
            <remarks>If you want to undo actions performed by this method, call this method using a Command object.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformAddEdge(`1)">
            <summary>
            Performs the Add action for the edge.
            </summary>
            <param name="edgeToAdd">The edge to add.</param>
            <remarks>If you want to undo actions performed by this method, call this method using a Command object.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformRemoveVertex(`0)">
            <summary>
            Performs the remove vertex.
            </summary>
            <param name="vertexToRemove">The vertex to remove.</param>
            <remarks>If you want to undo actions performed by this method, call this method using a Command object.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.PerformDisconnect(`0,`0,System.Boolean)">
            <summary>
            Performs the disconnect action for disconnecting two graph vertices. 
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
            <param name="bothSides">if set to true, the edges owned by both sides are removed, otherwise only the edges from startVertex to endVertex</param>
            <remarks>If you want to undo actions performed by this method, call this method using a Command object.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.RemoveOrphanedVertices">
            <summary>
            Removes the orphaned vertices.
            </summary>
            <remarks>Do not call this method directly if this is a commandified graph, call this through a command if no caller is called by a command</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.RemoveOrphanedVerticesAfterEdgeRemove(`1)">
            <summary>
            Removes the orphaned vertices after an edge remove, if the flag RemoveOrphanedVerticesOnEdgeRemoval has been set
            </summary>
            <param name="edgeRemoved">The edge removed.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.AddVertexToGraphStructure(`0)">
            <summary>
            Adds the passed in vertex to the graph structure.
            </summary>
            <param name="vertexToAdd">The vertex to add.</param>
            <remarks>Do not call this method directly, call Add() to add a vertex. This method is used to physically add the vertex to the datastructures</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.AddEdgeToGraphStructure(`1,`0,`0)">
            <summary>
            Adds the edge to the graph structure. The edge is between startVertex and endVertex specified. 
            </summary>
            <param name="edgeToAdd">The edge to add.</param>
            <param name="startVertex">The start vertex the edge belongs to</param>
            <param name="endVertex">The end vertex the edge belongs to.</param>
            <remarks>Do not call this method directly, call Add() to add an edge. This method is used to physically add the edge to the datastructures</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.RemoveEdgeFromGraphStructure(`1,`0,`0)">
            <summary>
            Removes the edge from the graph structure. The edge to remove is between startVertex and endVertex.
            </summary>
            <param name="edgeToRemove">The edge to remove.</param>
            <param name="startVertex">The start vertex the edge belongs to.</param>
            <param name="endVertex">The end vertex the edge belongs to.</param>
            <remarks>Do not call this method directly. Call Remove() to remove an edge. This method is used to physically remove the edge from the datastructures</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.RemoveVertexFromGraphStructure(`0)">
            <summary>
            Removes the vertex from graph structure. 
            </summary>
            <param name="vertexToRemove">The vertex to remove.</param>
            <remarks>Do not call this method directly. Call Remove() to remove a vertex. This method is used to physically remove the vertex from the datastructures</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphBase`2.RemoveVertexFromAdjacencyList(`0,`0)">
            <summary>
            Removes the vertex from adjacency list of the relatedVertex.
            </summary>
            <param name="vertexToRemove">The vertex to remove.</param>
            <param name="relatedVertex">The related vertex, which owns the adjancency list the vertex has to be removed from.</param>
            <remarks>Do not call this method directly. Call Remove() to remove a vertex. This method is used to physically remove the vertex from the datastructures</remarks>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.IsDirected">
            <summary>if true, the graph is directed and only EdgeBase instances which have IsDirected set to true are allowed,
            otherwise it's a non-directed graph and EdgeBase instances which have IsDirected set to false are accepted.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.Vertices">
            <summary>
            Returns the vertices in this graph. Enumerating this property will enumerate the inner structures of the graph, no copy is made. This requires
            a lock on <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> if <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.IsSynchronized"/> is set to true to make sure enumeration of this property is thread safe.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.Edges">
            <summary>
            Returns the edges in this graph. Enumerating this property will enumerate the inner structures of the graph, no copy is made. This requires
            a lock on <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> if <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.IsSynchronized"/> is set to true to make sure enumeration of this property is thread safe.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.VertexCount">
            <summary>
            Returns the number of vertices in this graph.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.EdgeCount">
            <summary>
            Returns the number of edges in this graph.
            If this graph is a directed graph, it counts the edge A to B as an edge, but B to A, if not present, isn't counted. A non-directed graph
            has an edge between A and B but also between B and A. This is counted as 1 edge, not two. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.EdgeProducerFunc">
            <summary>
            Gets or sets the edge producer func which produces edges for this graph. Used in some algorithms which have to produce edges. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.RemoveOrphanedVerticesOnEdgeRemoval">
            <summary>
            Gets or sets a value indicating whether vertices which are not part of any edge anymore are removed from the graph when the edge they're part 
            of is removed from the graph (so they effectively are orphaned). Default is false.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.Vertices"/> and <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.Edges"/> is synchronized (thread safe). Default: false. Set to true to in the ctor to
            make sure the operations on this object are using locks. Use <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot"/> to lock on the same object as this class' internal operations.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.Vertices"/> and <see cref="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.Edges"/> properties. It's the same object used in locks inside this object. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphBase`2.SuppressEvents">
            <summary>
            Gets or sets a value indicating whether events are blocked from being raised (true) or not (false, default)
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs`1">
            <summary>
            Class which is used to store event args in for the change event args of the graph.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs`1"/> class.
            </summary>
            <param name="involvedElement">the involved element which was involved in the change.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs`1.InvolvedElement">
            <summary>
            Gets or sets the involved element which was involved in the change
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.IEdge`1">
            <summary>
            Interface to be used with Edge classes in graphs.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.IEdge`1.StartVertex">
            <summary>
            Gets the start vertex of the edge.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.IEdge`1.EndVertex">
            <summary>
            Gets the end vertex of the edge. 
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.IEdge`1.IsDirected">
            <summary>
            Gets a value indicating whether this edge is directed. If true, the edge is directed from startVertex to endVertex and is seen as an edge only between
            startVertex and endVertex, not between endVertex and startVertex. If false, this edge isn't considered a directed edge and is seen as an edge between 
            startVertex and endVertex and also between endVertex and startVertex.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.IRootDetector">
            <summary>
            Simple interface which is used on the RootDetector class to be able to create multiple different typed instances in the same routine. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.IRootDetector.SearchForRoots">
            <summary>
            Searches for roots within the graph
            </summary>
            <returns>number of roots detected, 1 signifies a connected graph, more than 1 signifies a disconnected graph</returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.NonDirectedEdge`1">
            <summary>
            Class which represents a non-directed edge in a graph. A non-directed edge between A and B means that the edge represents A to B but also B to A.
            </summary>
            <typeparam name="TVertex">The type of the vertices in the graph.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedEdge`1.#ctor(`0,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedEdge`1"/> class.
            </summary>
            <param name="startVertex">The start vertex.</param>
            <param name="endVertex">The end vertex.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2">
            <summary>
            Basic class which simply makes the graph base act like a non-directed graph. 
            </summary>
            <typeparam name="TVertex">The type of the vertex.</typeparam>
            <typeparam name="TEdge">The type of the information inside the edge.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(System.Func{`0,`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(System.Func{`0,`0,`1},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(System.Func{`0,`0,`1},System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.NonDirectedGraph{`0,`1})">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.NonDirectedGraph{`0,`1},System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.NonDirectedGraph{`0,`1},System.Func{`0,`0,`1})">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.NonDirectedGraph{`0,`1},System.Func{`0,`0,`1},System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2.#ctor(SD.Tools.Algorithmia.Graphs.NonDirectedGraph{`0,`1},System.Func{`0,`0,`1},System.Boolean,System.Boolean)">
            <summary>
            Copy constructor of the <see cref="T:SD.Tools.Algorithmia.Graphs.NonDirectedGraph`2"/> class.
            </summary>
            <param name="graph">The graph.</param>
            <param name="edgeProducerFunc">The edge producer func which produces edges for this directed graph. Used in some algorithms which 
            have to produce edges.</param>
            <param name="isCommandified">If set to true, the graph is a commandified graph, which means all actions taken on this graph which mutate 
            graph state are undoable.</param>
            <param name="isSynchronized">if set to <c>true</c> this list is a synchronized collection, using a lock on SyncRoot to synchronize activity in multithreading
            scenarios</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.Graphs.SubGraphView`2">
            <summary>
            Class which represents a subgraph view on a main graph with a subset of the vertices/edges of the main graph.
            </summary>
            <typeparam name="TVertex">The type of the vertices in this graph.</typeparam>
            <typeparam name="TEdge">The type of the edges in the graph</typeparam>
            <remarks>SubGraphView instances are used to 'view' a subset of a bigger graph and maintain themselves based on the actions on the
            main graph. Adding/removing vertices / edges from this SubGraphView removes them only from this view, not from the main graph. Adding
            vertices/edges to the main graph will add the vertex/edge to this view if the added element meets criteria (implemented through polymorphism, 
            by default no criteria are set, so no vertex/edge is added if it's added to the main graph). Removing a vertex/edge from the main graph will remove
            the vertex / edge from this view if it's part of this view. As this view binds to events on the main graph, it's key to call Dispose() on an 
            instance of SubGraphView if it's no longer needed to make sure event handlers are cleaned up.
            This view has no adjacency lists, as they're located in the main graph. <br/><br/>
            If the graph specified is a synchronized graph, this view is also synchronized, and will sync its actions with the graph using the graph's SyncRoot object. 
            </remarks>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.VertexAdded">
            <summary>
            Event which is raised when a vertex has been added to this SubGraphView
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.VertexRemoved">
            <summary>
            Event which is raised when a vertex has been removed from this SubGraphView
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.VertexChanged">
            <summary>
            If TVertex supports change notification, this event is raised when a vertex in the subgraph view was changed
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.EdgeAdded">
            <summary>
            Event which is raised when an edge has been added to this SubGraphView
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.EdgeRemoved">
            <summary>
            Event which is raised when an edge has been removed from this SubGraphView
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.EdgeChanged">
            <summary>
            If TEdge supports change notification, this event is raised when an edge in the subgraph view was changed
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.IsEmpty">
            <summary>
            Event which is raised when the subgraphview is made empty. Observers can use this event to dispose an empty subgraphview to avoid dangling event handlers.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Disposed">
            <summary>
            Event which is raised when this instance was disposed.
            </summary>
        </member>
        <member name="E:SD.Tools.Algorithmia.Graphs.SubGraphView`2.HasBeenRemoved">
            <summary>
            Raised when the implementing element has been removed from its container
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.SubGraphView`2"/> class.
            </summary>
            <param name="mainGraph">The main graph this SubGraphView is a view on.</param>
            <remarks>Creates a non-commandified instance</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.#ctor(SD.Tools.Algorithmia.Graphs.GraphBase{`0,`1},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Graphs.SubGraphView`2"/> class.
            </summary>
            <param name="mainGraph">The main graph this SubGraphView is a view on.</param>
            <param name="isCommandified">If set to true, the SubGraphView is a commandified SubGraphView, which means all actions taken on this SubGraphView 
            which mutate its state are undoable.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Add(`0)">
            <summary>
            Adds the specified vertex.
            </summary>
            <param name="vertex">The vertex.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Add(`1)">
            <summary>
            Adds the specified edge. If the vertices aren't in the view, they're added too.
            </summary>
            <param name="edge">The edge.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Remove(`0)">
            <summary>
            Removes the vertex.
            </summary>
            <param name="toRemove">To remove.</param>
            <remarks>toRemove can't be null, as a graph can't have null vertices</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Remove(`1)">
            <summary>
            Removes the edge.
            </summary>
            <param name="toRemove">To remove.</param>
            <remarks>toRemove can't be null as a graph can't have null edges</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Contains(`0)">
            <summary>
            Determines whether this SubGraphView contains the passed in vertex.
            </summary>
            <param name="vertex">The vertex.</param>
            <returns>true if the vertex is in this SubGraphView, false otherwise. 
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Contains(`1)">
            <summary>
            Determines whether this SubGraphView contains the passed in edge.
            </summary>
            <param name="edge">The edge.</param>
            <returns>
            true if the edge is in this SubGraphView, false otherwise.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.MarkAsRemoved">
            <summary>
            Marks this instance as removed. It raises ElementRemoved
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.BindEvents">
            <summary>
            Binds the event handlers to the events of the main graph.
            </summary>
            <remarks>Use this method to Bind the view to the main graph again when the view is added to a list in an undo-redo system if the events are
            unbound using UnbindEvents in the removal action.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.UnbindEvents">
            <summary>
            Unbinds the event handlers from the events of the main graph.
            </summary>
            <remarks>Use this method to unbind the view from the main graph in an undo-redo system rather than calling Dispose(), as
            Dispose can't be undone and if a subgraphview's removal has to be undone, BindEvents() has to be called again.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.OnVertexAdded(`0)">
            <summary>
            Called when a vertex has been added to this view
            </summary>
            <param name="vertex">The vertex.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.OnEdgeAdded(`1)">
            <summary>
            Called when an edge has been added to this view
            </summary>
            <param name="edge">The edge.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.OnVertexRemoved(`0)">
            <summary>
            Called when a vertex has been removed from this view
            </summary>
            <param name="vertex">The vertex.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.OnEdgeRemoved(`1)">
            <summary>
            Called when an edge has been removed from this view
            </summary>
            <param name="edge">The edge.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.HandleVertexAddedToMainGraph(`0)">
            <summary>
            Handles the event that a new vertex was added to the main graph.
            </summary>
            <param name="vertexAdded">The vertex added.</param>
            <remarks>By default, this routine does nothing. If you want to add this vertex to this SubGraphView, you've to add it by calling Add
            in a derived class, overriding this method.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.HandleEdgeAddedToMainGraph(`1)">
            <summary>
            Handles the event that a new edge was added to the main graph
            </summary>
            <param name="edgeAdded">The edge added.</param>
            <remarks>By default, this routine does nothing. If you want to add this edge to this SubGraphView, you've to add it by calling Add
            in a derived class, overriding this method.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.HandleEdgeRemovedFromMainGraph(`1)">
            <summary>
            Handles the event that an edge was removed from the main graph.
            </summary>
            <param name="edgeRemoved">The edge removed.</param>
            <remarks>The view automatically updates its own datastructures already, so use this method to perform additional work</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.HandleVertexRemovedFromMainGraph(`0)">
            <summary>
            Handles the event that a vertex was removed from the main graph.
            </summary>
            <param name="vertexRemoved">The vertex removed.</param>
            <remarks>The view automatically updates its own datastructures already, so use this method to perform additional work</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.PerformSyncedAction(System.Action)">
            <summary>
            Performs the specified action, either inside a lock on MainGraph.SyncRoot if thegraph is Synchronized, or normally, if the graph isn't synchronized.
            </summary>
            <param name="toPerform">To perform.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.PerformSyncedAction``1(System.Func{``0})">
            <summary>
            Performs the specified action, either inside a lock on MainGraph.SyncRoot if the graph is Synchronized, or normally, if the graph isn't synchronized.
            </summary>
            <typeparam name="T">The type of the element to return</typeparam>
            <param name="toPerform">To perform.</param>
            <returns>the result of toPerform</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.OnDisposing">
            <summary>
            Called when Disposing
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.RemoveEdgesWithVertex(`0)">
            <summary>
            Removes the edges with vertex, which is necessary when a vertex is removed so all dangling edges are removed as well. 
            </summary>
            <param name="vertex">The vertex.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.BindToINotifyPropertyChanged``1(``0)">
            <summary>
            Binds to INotifyPropertyChanged on the item specified
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.UnbindFromINotifyPropertyChanged``1(``0)">
            <summary>
            Unbinds from INotifyPropertyChanged on the item specified
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.OnElementPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            Called when the PropertyChanged event was raised by an element in this list.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.CheckIsEmpty">
            <summary>
            Checks if the subgraphview is empty and if so, it raises IsEmpty
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.MainGraph_VertexRemoved(System.Object,SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs{`0})">
            <summary>
            Handles the VertexRemoved event of the MainGraph control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.MainGraph_VertexAdded(System.Object,SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs{`0})">
            <summary>
            Handles the VertexAdded event of the MainGraph control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.MainGraph_EdgeRemoved(System.Object,SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs{`1})">
            <summary>
            Handles the EdgeRemoved event of the MainGraph control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.MainGraph_EdgeAdded(System.Object,SD.Tools.Algorithmia.Graphs.GraphChangeEventArgs{`1})">
            <summary>
            Handles the EdgeAdded event of the MainGraph control.
            </summary>
            <param name="sender">The source of the event.</param>
            <param name="e">The event arguments instance containing the event data.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to release only unmanaged resources.</param>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.SubGraphView`2.MainGraph">
            <summary>
            Gets the main graph this SubGraphView is a view on
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Vertices">
            <summary>
            Gets the vertices contained in this SubGraphView. All vertices are part of this.MainGraph. Enumerating this property will enumerate the inner structures of the SubGraphView, 
            no copy is made. This requires a lock on this.MainGraph.SyncRoot if this.MainGraph.IsSynchronized is set to true to make sure enumeration of this property is thread safe.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Graphs.SubGraphView`2.Edges">
            <summary>
            Gets the edges contained in this SubGraphView. All edges are part of this.MainGraph. All vertices are part of this.MainGraph. Enumerating this property will enumerate the 
            inner structures of the SubGraphView, no copy is made. This requires a lock on this.MainGraph.SyncRoot if this.MainGraph.IsSynchronized is set to true to make sure enumeration of 
            this property is thread safe.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Heaps.BinaryHeap`1">
            <summary>
            Simple heap which is based on a binary tree: the binary heap. See: http://en.wikipedia.org/wiki/Binary_heap
            Binary heaps are quite efficient, however if you're doing a lot of merging between heaps, the Binary heap is inefficient. Consider a Fibonacci heap
            instead in these situations.
            </summary>
            <remarks>Heaps can't store value types. This is because changing a value type really makes it a different value, while changing the contents of an object doesn't
            make it a different object.
            </remarks>
            <typeparam name="TElement">The type of the elements in this heap</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.#ctor(System.Comparison{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Heaps.BinaryHeap`1"/> class.
            </summary>
            <param name="keyCompareFunc">The key compare func, which is used to compare two elements based on their key. Based on the type of the heap, min heap
            or max heap, the first element is placed as parent or as child: if this heap is a min-heap, and the first element, according to keyCompareFunc is
            bigger than the second element, the second element will be the parent of the first element. In a max-heap, the first element will be the parent of
            the second element in that situation.</param>
            <param name="isMinHeap">Flag to signal if this heap is a min heap or a max heap</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.ExtractRoot">
            <summary>
            Extracts and removes the root of the heap.
            </summary>
            <returns>
            the root element deleted, or null/default if the heap is empty
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.UpdateKey``1(`0,System.Action{`0,``0},``0)">
            <summary>
            Updates the key of the element passed in. Only use this method for elements where the key is a property of the element, not the element itself.
            This means that if you have a heap with value typed elements (e.g. integers), updating the key is updating the value of the element itself, and because
            a heap might contain elements with the same value, this could lead to undefined results.
            </summary>
            <typeparam name="TKeyType">The type of the key type.</typeparam>
            <param name="element">The element which key has to be updated</param>
            <param name="keyUpdateFunc">The key update func, which takes 2 parameters: the element to update and the new key value.</param>
            <param name="newValue">The new value for the key.</param>
            <remarks>The element to update is first looked up in the heap. If the new key violates the heap property (e.g. the key is bigger than the
            key of the parent in a max-heap) the elements in the heap are restructured in such a way that the heap again obeys the heap property. </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Insert(`0)">
            <summary>
            Inserts the specified element into the heap at the right spot
            </summary>
            <param name="element">The element to insert.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Merge(SD.Tools.Algorithmia.Heaps.BinaryHeap{`0})">
            <summary>
            Merges the specified heap into this heap.
            </summary>
            <param name="toMerge">The heap to merge into this heap. This heap will be empty after the merge</param>
            <remarks>Merging is expensive with this heap implementation. Consider another heap class if you are doing a lot of merging</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Clear">
            <summary>
            Clears all elements from the heap
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Remove(`0)">
            <summary>
            Removes the element specified
            </summary>
            <param name="element">The element to remove.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Contains(`0)">
            <summary>
            Determines whether this heap contains the element specified
            </summary>
            <param name="element">The element.</param>
            <returns>
            true if the heap contains the element specified, false otherwise
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.InitDataStructures">
            <summary>
            Inits the data structures for this heap.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.FindIndexOfElement(`0)">
            <summary>
            Finds the index of the element passed in. If element is a valuetyped object, e.g. an integer, it means that there can be more elements with the same
            value in the heap. In that case, the index of the first element found is returned.
            </summary>
            <param name="element">The element.</param>
            <returns>the index of the element passed in in the _elements array, or -1 if not found</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.FindIndexOfElement(`0,System.Int32)">
            <summary>
            Finds the index of the element passed in. If element is a valuetyped object, e.g. an integer, it means that there can be more elements with the same
            value in the heap. In that case, the index of the first element found is returned.
            </summary>
            <param name="element">The element.</param>
            <param name="index">The current index to consider.</param>
            <returns>
            the index of the element passed in in the _elements array, or -1 if not found
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Upheap(System.Int32)">
            <summary>
            Checks the element at the index specified to see if it is at the wrong spot. If so, it is exchanged with its parent till the root is reached or the heap
            is already stable.
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Downheap(System.Int32)">
            <summary>
            Checks the element at the index specified to see if it is at the wrong spot. If so, it is exchanged with it's larger child till the last element is
            reached or the heap is stable
            </summary>
            <param name="index">The index.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the index passed in from the heap and restructures the elements to fulfill the heap property again.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Root">
            <summary>
            Gets the root of the heap. Depending on the fact if this is a min or max heap, it returns the element with the minimum key (min heap) or the element
            with the maximum key (max heap). If the heap is empty, null / default is returned
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.BinaryHeap`1.Count">
            <summary>
            Gets the number of elements in the heap.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1">
            <summary>
            Implementation of a Fibonacci heap. See: http://en.wikipedia.org/wiki/Fibonacci_heap for details about the Fibonacci heap. A Fibonacci heap is a heap with
            on average one of the fastest characteristics of all known heap datastructures to date. However, the efficiency is expressed as 'amortized' time, which means 
            it's averaged: the fastest operations are a little slower as some other operations can be rather time consuming in some situations. There are cases where a 
            Binomial heap (http://en.wikipedia.org/wiki/Binomial_heap) would be more efficient, however as in general the Fibonacci heap performs more efficiently, 
            this library contains an implementation of Fibonacci heap instead of a Binomial heap.
            <para>
            Some time ago another variant (actually two variants) of the Fibonacci heap, the 'Relaxed' Fibonacci Heap has been proposed, one has the same characteristics as
            the Fibonacci heap and one has some operations more efficient. As the implementation of a Relaxed Fibonacci Heap is quite complex we've postponed its 
            implementation till a later date. For more information about Relaxed Fibonacci Heaps, please see: http://www.pmg.lcs.mit.edu/~chandra/publications/heap.pdf
            Relaxed Fibonacci Heaps have a slight advantage in parallel environments.
            </para>
            </summary>
            <typeparam name="TElement">The type of the element in the heap.</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.#ctor(System.Comparison{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1"/> class.
            </summary>
            <param name="keyCompareFunc">The key compare func, which is used to compare two elements based on their key. Based on the type of the heap, min heap
            or max heap, the first element is placed as parent or as child: if this heap is a min-heap, and the first element, according to keyCompareFunc is
            bigger than the second element, the second element will be the parent of the first element. In a max-heap, the first element will be the parent of
            the second element in that situation.</param>
            <param name="isMinHeap">Flag to signal if this heap is a min heap or a max heap</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.ExtractRoot">
            <summary>
            Extracts and removes the root of the heap.
            </summary>
            <returns>
            the root element deleted, or null/default if the heap is empty
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.UpdateKey``1(`0,System.Action{`0,``0},``0)">
            <summary>
            Updates the key of the element passed in. Only use this method for elements where the key is a property of the element, not the element itself.
            This means that if you have a heap with value typed elements (e.g. integers), updating the key is updating the value of the element itself, and because
            a heap might contain elements with the same value, this could lead to undefined results.
            </summary>
            <typeparam name="TKeyType">The type of the key type.</typeparam>
            <param name="element">The element which key has to be updated</param>
            <param name="keyUpdateFunc">The key update func, which takes 2 parameters: the element to update and the new key value.</param>
            <param name="newValue">The new value for the key.</param>
            <remarks>First, the element to update is looked up in the heap. If the new key violates the heap property (e.g. the key is bigger than the
            key of the parent in a max-heap) the elements in the heap are restructured in such a way that the heap again obeys the heap property. </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.Insert(`0)">
            <summary>
            Inserts the specified element into the heap at the right spot. 
            </summary>
            <param name="element">The element to insert.</param>
            <remarks>It's not possible to add an element twice as this leads to problems with removal and lookup routines for elements: which node to process?</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.Merge(SD.Tools.Algorithmia.Heaps.FibonacciHeap{`0})">
            <summary>
            Merges the specified heap into this heap.
            </summary>
            <param name="toMerge">The heap to merge into this heap.</param>
            <remarks>Merge of two fibonacci heaps is considered O(1). This heap implementation keeps some datastructures for quickly finding elements back.
            Although these datastructures have an O(1) insert performance characteristic, it can be that the merge performance of this implementation is 
            actually slightly less efficient than O(1) with large heaps
            <para>
            This routine merges objects inside toMerge into this object. This means that this object will have references to objects inside toMerge.
            It's therefore not recommended to alter toMerge after this operation.
            </para>
            </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.Clear">
            <summary>
            Clears all elements from the heap
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.Remove(`0)">
            <summary>
            Removes the element specified
            </summary>
            <param name="element">The element to remove.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.Contains(`0)">
            <summary>
            Determines whether this heap contains the element specified
            </summary>
            <param name="element">The element.</param>
            <returns>
            true if the heap contains the element specified, false otherwise
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.InitDataStructures">
            <summary>
            Inits the data structures for this heap.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.ConvertToNewTreeInHeap(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Converts the passed in node to a new tree in heap.
            </summary>
            <param name="elementNode">The element node.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.CheckIfElementViolatesHeap(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Checks if the element passed in violates the heap. If so, true is returned, otherwise false. 
            </summary>
            <param name="elementNode">The element node.</param>
            <returns>true if the element violates the heap (not at the right spot in the trees), false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.ConsolidateTrees">
            <summary>
            Consolidates the trees in this heap so there's at most 1 tree per tree degree. It also finds the root of the tree (min/max) and sets _heapRoot.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.RemoveInternal(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Removes the heapnode passed in from the heap.
            </summary>
            <param name="nodeToRemove">The node to remove.</param>
            <remarks>This routine doesn't collide trees, as that's only necessary if the heaproot is removed. </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.UpdateRootIfRequired(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Updates the root of this heap if required.
            </summary>
            <param name="node">The node to check if it should become the new root.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.AddElementNodeMapping(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Adds the element-node relation of the node passed in to the element node mappings. 
            </summary>
            <param name="newNode">The new node.</param>
            <remarks>Assumes newNode doesn't exist in heap.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.RemoveElementNodeMapping(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Removes the element-node relation from the element node mappings
            </summary>
            <param name="nodeToRemove">The node to remove.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.FindNode(`0)">
            <summary>
            Finds the node of the element passed in.
            </summary>
            <param name="element">The element.</param>
            <returns>the node instance which contains the element passed in or null if not found</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.Root">
            <summary>
            Gets the root of the heap. Depending on the fact if this is a min or max heap, it returns the element with the minimum key (min heap) or the element
            with the maximum key (max heap). If the heap is empty, null / default is returned
            </summary>
            <value></value>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.FibonacciHeap`1.Count">
            <summary>
            Gets the number of elements in the heap.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1">
            <summary>
            Class which is used as a heap element in the internal trees inside a Fibonacci heap.
            </summary>
            <typeparam name="TElement">The element contained inside this node</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1"/> class.
            </summary>
            <param name="contents">The contents.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.CutChild(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Cuts the child passed in from this node. If this node isn't a root, it will be marked after this operation.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.AddChild(SD.Tools.Algorithmia.Heaps.FibonacciHeapNode{`0})">
            <summary>
            Adds the tree specified by its head 'child' as a child of this node.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.BecomeTreeRoot">
            <summary>
            Becomes the root of a tree in the heap. Becoming a root means it has to be unmarked and the parent has to be null.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.CutFromParent">
            <summary>
            Cuts this child from its parent. Calls into parent to remove this node as its child. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.Degree">
            <summary>
            Gets the degree of the tree with this node as the root. The degree is the number of children.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.Parent">
            <summary>
            Gets or sets the parent heap element of this element
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.Children">
            <summary>
            Gets or sets the children of this heap element. Children are stored in a doubly linked list.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.Contents">
            <summary>
            Gets the contents of this heap element
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.FibonacciHeapNode`1.IsMarked">
            <summary>
            Gets or sets a value indicating whether this instance is marked.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.Heaps.HeapBase`1">
            <summary>
            General base class for all Heap classes. A heap is a specialized tree-based datastructure which has its elements ordered in such a way that
            every parent is larger / equal than its children, if the heap is a max-heap and in the case of a min-heap every parent is smaller/equal than its
            children. See: http://en.wikipedia.org/wiki/Heap_%28data_structure%29<br/>
            The heap classes implement the basic operations on a heap: delete max/min, increase/decrease key, insert and merge. 
            </summary>
            <remarks>
            As this class can both handle min heaps as well as max heaps, the delete max/min is called 'ExtractRoot'. The increase/decrease key method is called
            'UpdateKey'.
            <para>
            Heaps can't store value types. This is because changing a value type really makes it a different value, while changing the contents of an object doesn't
            make it a different object.
            </para>
            </remarks>
            <typeparam name="TElement">The type of the elements in this heap</typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.HeapBase`1.#ctor(System.Comparison{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.Heaps.HeapBase`1"/> class.
            </summary>
            <param name="keyCompareFunc">The key compare func, which is used to compare two elements based on their key. Based on the type of the heap, min heap
            or max heap, the first element is placed as parent or as child: if this heap is a min-heap, and the first element, according to keyCompareFunc is
            bigger than the second element, the second element will be the parent of the first element. In a max-heap, the first element will be the parent of
            the second element in that situation.</param>
            <param name="isMinHeap">Flag to signal if this heap is a min heap or a max heap</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.HeapBase`1.ExtractRoot">
            <summary>
            Extracts and removes the root of the heap.
            </summary>
            <returns>the root element deleted, or null/default if the heap is empty</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.HeapBase`1.UpdateKey``1(`0,System.Action{`0,``0},``0)">
            <summary>
            Updates the key of the element passed in. Only use this method for elements where the key is a property of the element, not the element itself.
            This means that if you have a heap with value typed elements (e.g. integers), updating the key is updating the value of the element itself, and because
            a heap might contain elements with the same value, this could lead to undefined results.
            </summary>
            <typeparam name="TKeyType">The type of the key type.</typeparam>
            <param name="element">The element which key has to be updated</param>
            <param name="keyUpdateFunc">The key update func, which takes 2 parameters: the element to update and the new key value.</param>
            <param name="newValue">The new value for the key.</param>
            <remarks>The element to update is first looked up in the heap. If the new key violates the heap property (e.g. the key is bigger than the
            key of the parent in a max-heap) the elements in the heap are restructured in such a way that the heap again obeys the heap property. </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.HeapBase`1.Insert(`0)">
            <summary>
            Inserts the specified element into the heap at the right spot
            </summary>
            <param name="element">The element to insert.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.HeapBase`1.Clear">
            <summary>
            Clears all elements from the heap
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.HeapBase`1.Remove(`0)">
            <summary>
            Removes the element specified
            </summary>
            <param name="element">The element to remove.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Heaps.HeapBase`1.Contains(`0)">
            <summary>
            Determines whether this heap contains the element specified
            </summary>
            <param name="element">The element.</param>
            <returns>true if the heap contains the element specified, false otherwise</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.HeapBase`1.Root">
            <summary>
            Gets the root of the heap. Depending on the fact if this is a min or max heap, it returns the element with the minimum key (min heap) or the element
            with the maximum key (max heap). If the heap is empty, null / default is returned
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.HeapBase`1.Count">
            <summary>
            Gets the number of elements in the heap.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.HeapBase`1.KeyCompareFunc">
            <summary>
            Gets the key compare func to compare elements based on key.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.HeapBase`1.ElementCompareFunc">
            <summary>
            Gets the element compare func, which is the func to compare two elements based on the heap type: the function returns true if the first element
            is indeed the correct parent of the second element or false if not.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.Heaps.HeapBase`1.IsMinHeap">
            <summary>
            Gets a value indicating whether this instance is a min heap (true) or a max heap (false)
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1">
            <summary>
            Priority queue class based on a binary heap which is set as a max heap, as a priority queue always has the element with the highest value (key) as the first
            element
            </summary>
            <typeparam name="TElement">The type of the elements in the queue</typeparam>
            <remarks>Heaps don't allow enumeration (as enumeration destroys the heap as the elements have to be extracted), so enumerating this
            priority queue will throw an exception.
            <para>Heaps can't store value types. This is because changing a value type really makes it a different value, while changing the contents of an object doesn't
            make it a different object. This priority queue, based on a heap, can't store value types either.
            </para>
            </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.#ctor(System.Comparison{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1"/> class.
            </summary>
            <param name="priorityComparison">The priority comparison.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.Peek">
            <summary>
            Peeks at the first element of the queue (the one with the highest priority, according to the priority comparison) and returns that element
            without removing it
            </summary>
            <returns></returns>
            the first element in the queue or the default value for TElement if the queue is empty
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.Add(`0)">
            <summary>
            Adds the specified element to the queue
            </summary>
            <param name="element">The element to add.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.Remove">
            <summary>
            Removes the first element from the queue, if the queue isn't empty.
            </summary>
            <returns>
            the first element of the queue or the default value for TElement if the queue is empty
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.Clear">
            <summary>
            Clears the queue.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.Contains(`0)">
            <summary>
            Determines whether the queue contains the element specified
            </summary>
            <param name="elementToCheck">The element to check.</param>
            <returns>
            true if elementToCheck is in the queue, false otherwise
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.GetEnumerator">
            <summary>
            Throws a NotSupportException, as binary heaps can't be enumerated.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.InitDataStructures">
            <summary>
            Inits the data structures of this priority queue
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.PriorityQueues.BinaryHeapPriorityQueue`1.Count">
            <summary>
            Gets the number of elements in the queue
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1">
            <summary>
            Base class for all priority queues. A priority queue is a special queue: the elements added to the queue are stored in the order of the priority
            they have. Grabbing the first element from a queue is therefore grabbing the element with the highest priority.
            See: http://en.wikipedia.org/wiki/Priority_queue
            </summary>
            <typeparam name="TElement">the type of the element in the queue</typeparam>
            <remarks>If you store value types in this queue, be aware that Peek() and Remove() on an empty queue will return the default value for
            the value type used, e.g. 0 for a priority queue with Int32 values.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.#ctor(System.Comparison{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1"/> class.
            </summary>
            <param name="priorityComparison">The priority comparison.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.System#Collections#Generic#IEnumerable{TElement}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.Peek">
            <summary>
            Peeks at the first element of the queue (the one with the highest priority, according to the priority comparison) and returns that element
            without removing it
            </summary>
            the first element in the queue or the default value for TElement if the queue is empty
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.Add(`0)">
            <summary>
            Adds the specified element to the queue
            </summary>
            <param name="element">The element to add.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.Remove">
            <summary>
            Removes the first element from the queue, if the queue isn't empty. 
            </summary>
            <returns>the first element of the queue or the default value for TElement if the queue is empty</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.Clear">
            <summary>
            Clears the queue.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.Contains(`0)">
            <summary>
            Determines whether the queue contains the element specified
            </summary>
            <param name="element">The element to check.</param>
            <returns>true if elementToCheck is in the queue, false otherwise</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.GetEnumerator">
            <summary>
            Gets the enumerator for this queue
            </summary>
            <returns>the enumerator to use over this queue</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.PriorityComparison">
            <summary>
            Gets the priority comparison.
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.PriorityQueues.PriorityQueueBase`1.Count">
            <summary>
            Gets the number of elements in the queue
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1">
            <summary>
            Simple priority queue which uses a simple list for storing the elements. Inserts are very fast, O(1), but lookups are done in linear time, O(n).
            </summary>
            <typeparam name="TElement">The type of the elements in this queue</typeparam>
            <remarks>If you store value types in this queue, be aware that Peek() and Remove() on an empty queue will return the default value for
            the value type used, e.g. 0 for a priority queue with Int32 values.</remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.#ctor(System.Comparison{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1"/> class.
            </summary>
            <param name="priorityComparison">The priority comparison.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.Peek">
            <summary>
            Peeks at the first element of the queue (the one with the highest priority, according to the priority comparison) and returns that element
            without removing it
            </summary>
            <returns>
            the first element in the queue or the default value for TElement if the queue is empty
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.Add(`0)">
            <summary>
            Adds the specified element to the queue
            </summary>
            <param name="element">The element to add.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.Remove">
            <summary>
            Removes the first element from the queue, if the queue isn't empty.
            </summary>
            <returns>
            the first element of the queue or the default value for TElement if the queue is empty
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.Clear">
            <summary>
            Clears the queue.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.Contains(`0)">
            <summary>
            Determines whether the queue contains the element specified
            </summary>
            <param name="element">The element to check.</param>
            <returns>
            true if elementToCheck is in the queue, false otherwise
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.GetEnumerator">
            <summary>
            Gets the enumerator for this queue
            </summary>
            <returns>the enumerator to use over this queue</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.InitDataStructures">
            <summary>
            Inits the data structures of this priority queue
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.PriorityQueues.SimplePriorityQueue`1.Count">
            <summary>
            Gets the number of elements in the queue
            </summary>
            <value></value>
        </member>
        <member name="T:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1">
            <summary>
            Simple priority queue which uses a list for storing the elements which is always kept sorted. 
            Inserts can be slow, as worst case inserts (insert at the front) requires a move of all elements, so the order is somewhere around the order of
            insertion sort, O((n^2)/4). Lookups and removals are very fast: O(1).
            </summary>
            <typeparam name="TElement">The type of the elements in this queue</typeparam>
            <remarks>If you store value types in this queue, be aware that Peek() and Remove() on an empty queue will return the default value for
            the value type used, e.g. 0 for a priority queue with Int32 values. Therefore, consult Count to check whether there are any values in the queue.
            </remarks>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.#ctor(System.Comparison{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1"/> class.
            </summary>
            <param name="priorityComparison">The priority comparison func.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.Peek">
            <summary>
            Peeks at the first element of the queue (the one with the highest priority, according to the priority comparison) and returns that element
            without removing it
            </summary>
            <returns>
            the first element in the queue or the default value for TElement if the queue is empty
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.Add(`0)">
            <summary>
            Adds the specified element to the queue
            </summary>
            <param name="element">The element to add.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.Remove">
            <summary>
            Removes the first element from the queue, if the queue isn't empty.
            </summary>
            <returns>
            the first element of the queue or the default value for TElement if the queue is empty
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.Clear">
            <summary>
            Clears the queue.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.Contains(`0)">
            <summary>
            Determines whether the queue contains the element specified
            </summary>
            <param name="element">The element to check.</param>
            <returns>
            true if elementToCheck is in the queue, false otherwise
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.GetEnumerator">
            <summary>
            Gets the enumerator for this queue
            </summary>
            <returns>the enumerator to use over this queue</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.InitDataStructures">
            <summary>
            Inits the data structures of this priority queue
            </summary>
        </member>
        <member name="P:SD.Tools.Algorithmia.PriorityQueues.SortedPriorityQueue`1.Count">
            <summary>
            Gets the number of elements in the queue
            </summary>
            <value></value>
        </member>
        <member name="T:SD.Tools.Algorithmia.Sorting.ISortAlgorithm">
            <summary>
            Interface to define a sort algorithm type
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.ISortAlgorithm.Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortDirection,System.Int32,System.Int32,System.Comparison{``0})">
            <summary>
            Sorts the specified list in the direction specified.
            </summary>
            <typeparam name="T">type of element to sort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="direction">The direction to sort the elements in toSort.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
            <param name="compareFunc">The compare func.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.Sorting.QuickSorter">
            <summary>
            Implements the quick sort algorithm. See: http://en.wikipedia.org/wiki/Quick_sort
            The class implements Quicksort again, even though .NET already implements QuickSort, because the sort should be done
            in-place. Using .NET's quicksort algorithm would require a copy to an array and back into the list to sort, which could be an expensive operation with
            large collections to sort.
            Algorithm is based on Wikipedia's algorithm.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.QuickSorter.SD#Tools#Algorithmia#Sorting#ISortAlgorithm#Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortDirection,System.Int32,System.Int32,System.Comparison{``0})">
            <summary>
            Sorts the specified list in the direction specified.
            </summary>
            <typeparam name="T">type of element to sort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="direction">The direction to sort the elements in toSort.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
            <param name="compareFunc">The compare func.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.QuickSorter.PerformSort``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Func{``0,``0,System.Boolean})">
            <summary>
            Performs the sort of a partition in the list. This routine is called recursively.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toSort">To sort.</param>
            <param name="left">The left index.</param>
            <param name="right">The right index.</param>
            <param name="valueComparerTest">The value comparer test.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.QuickSorter.Partition``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.Int32,System.Func{``0,``0,System.Boolean})">
            <summary>
            Partitions the specified list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toSort">To sort.</param>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <param name="pivotIndex">Index of the pivot.</param>
            <param name="valueComparerTest">The value comparer test.</param>
            <returns>index for new pivot point</returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.Sorting.SelectionSorter">
            <summary>
            Implements the selection sort algorithm. See: http://en.wikipedia.org/wiki/Selection_sort
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SelectionSorter.SD#Tools#Algorithmia#Sorting#ISortAlgorithm#Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortDirection,System.Int32,System.Int32,System.Comparison{``0})">
            <summary>
            Sorts the specified list in the direction specified.
            </summary>
            <typeparam name="T">type of element to sort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="direction">The direction to sort the elements in toSort.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
            <param name="compareFunc">The compare func.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.Sorting.ShellSorter">
            <summary>
            Implements the shell sort algorithm. See: http://en.wikipedia.org/wiki/Shell_sort
            The algorithm implemented below is from Sedgewick: http://www.cs.princeton.edu/~rs/shell/
            It uses Sedgewick's increments values, as described in this paper: http://www.cs.princeton.edu/~rs/shell/paperF.pdf
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.ShellSorter.SD#Tools#Algorithmia#Sorting#ISortAlgorithm#Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortDirection,System.Int32,System.Int32,System.Comparison{``0})">
            <summary>
            Sorts the specified list in the direction specified.
            </summary>
            <typeparam name="T">type of element to sort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="direction">The direction to sort the elements in toSort.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
            <param name="compareFunc">The compare func.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.Sorting.SortAlgorithmFactory">
            <summary>
            Factory to create sort algorithm instances which are then used to sort a list
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SortAlgorithmFactory.CreateSortAlgorithmImplementation(SD.Tools.Algorithmia.SortAlgorithm)">
            <summary>
            Creates the sort algorithm implementation.
            </summary>
            <param name="algorithm">The algorithm.</param>
            <returns></returns>
        </member>
        <member name="T:SD.Tools.Algorithmia.Sorting.SortingExtensionMethods">
            <summary>
            Static class which contains the extension method for IList(Of T) implementations to sort these implementations using various sorting algorithms.
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SortingExtensionMethods.Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortAlgorithm,SD.Tools.Algorithmia.SortDirection)">
            <summary>
            Sorts the specified IList(Of T) using the algorithm specified in the order specified.
            </summary>
            <typeparam name="T">type of the elements in toSort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="algorithm">The algorithm to use.</param>
            <param name="direction">The direction to sort the elements in.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SortingExtensionMethods.Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortAlgorithm,SD.Tools.Algorithmia.SortDirection,System.Comparison{``0})">
            <summary>
            Sorts the specified IList(Of T) using the algorithm specified in the order specified.
            </summary>
            <typeparam name="T">type of the elements in toSort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="algorithm">The algorithm to use.</param>
            <param name="direction">The direction to sort the elements in.</param>
            <param name="compareFunc">The compare func to compare two elements in the list to sort.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SortingExtensionMethods.Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortAlgorithm,SD.Tools.Algorithmia.SortDirection,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the specified IList(Of T) using the algorithm specified in the order specified.
            </summary>
            <typeparam name="T">type of the elements in toSort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="algorithm">The algorithm to use.</param>
            <param name="direction">The direction to sort the elements in.</param>
            <param name="comparer">The comparer to use. If set to null, the default comparer for T is used.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SortingExtensionMethods.Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortAlgorithm,SD.Tools.Algorithmia.SortDirection,System.Int32,System.Int32)">
            <summary>
            Sorts the specified IList(Of T) using the algorithm specified in the order specified.
            </summary>
            <typeparam name="T">type of the elements in toSort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="algorithm">The algorithm to use.</param>
            <param name="direction">The direction to sort the elements in.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SortingExtensionMethods.Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortAlgorithm,SD.Tools.Algorithmia.SortDirection,System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the specified IList(Of T) using the algorithm specified in the order specified.
            </summary>
            <typeparam name="T">type of the elements in toSort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="algorithm">The algorithm to use.</param>
            <param name="direction">The direction to sort the elements in.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
            <param name="comparer">The comparer to use. If set to null, the default comparer for T is used.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.Sorting.SortingExtensionMethods.Sort``1(System.Collections.Generic.IList{``0},SD.Tools.Algorithmia.SortAlgorithm,SD.Tools.Algorithmia.SortDirection,System.Int32,System.Int32,System.Comparison{``0})">
            <summary>
            Sorts the specified IList(Of T) using the algorithm specified in the order specified.
            </summary>
            <typeparam name="T">type of the elements in toSort</typeparam>
            <param name="toSort">the list to sort.</param>
            <param name="algorithm">The algorithm to use.</param>
            <param name="direction">The direction to sort the elements in.</param>
            <param name="startIndex">The start index.</param>
            <param name="endIndex">The end index.</param>
            <param name="compareFunc">The compare func to compare two elements in the list to sort.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.UtilityClasses.ArgumentVerifier">
            <summary>
            Class which contains argument verification logic and which can throw exceptions if necessary. This code makes it easier to verify input arguments. 
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.ArgumentVerifier.CantBeNull(System.Object,System.String)">
            <summary>
            Checks the argument passed in. if it's null, it throws an ArgumentNullException
            </summary>
            <param name="argument">The argument.</param>
            <param name="name">The name.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.ArgumentVerifier.ShouldBeTrue``1(System.Func{``0,System.Boolean},``0,System.String)">
            <summary>
            Checks if the argument returns true with the func passed in. If not, it throws an ArgumentException with the error message specified. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="checkFunc">The check func.</param>
            <param name="argument">The argument.</param>
            <param name="formattedError">The formatted error message.</param>
        </member>
        <member name="T:SD.Tools.Algorithmia.UtilityClasses.ComparisonBasedComparer`1">
            <summary>
            Generic comparer which uses a comparison func to implement the compare method
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.ComparisonBasedComparer`1.#ctor(System.Comparison{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:SD.Tools.Algorithmia.UtilityClasses.ComparisonBasedComparer`1"/> class.
            </summary>
            <param name="compareFunc">The compare func.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.ComparisonBasedComparer`1.Compare(`0,`0)">
            <summary>
            Compares the two passed in elements using the set compareFunc.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>
            the result of the compareFunc applied to the two input parameters. If FlipCompareResult is set to true, the result is negated.</returns>
        </member>
        <member name="P:SD.Tools.Algorithmia.UtilityClasses.ComparisonBasedComparer`1.FlipCompareResult">
            <summary>
            Gets or sets the flag which, if set to true, makes the Compare method flip its result: -1 becomes 1 and 1 becomes -1. This flag can be used to
            use the comparer in descending sorted lists.
            </summary>
        </member>
        <member name="T:SD.Tools.Algorithmia.UtilityClasses.GeneralUtils">
            <summary>
            General set of utility routines
            </summary>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.GeneralUtils.GetUsableComparison``1(System.Collections.Generic.IComparer{``0})">
            <summary>
            Gets a usable comparison for the comparer passed in.
            </summary>
            <typeparam name="T">the type comparer works on</typeparam>
            <param name="comparer">The comparer.</param>
            <returns>
            usable comparison
            </returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.GeneralUtils.ValuesAreEqual(System.Object,System.Object)">
            <summary>
            Compares the two values passed in and checks if they're value-wise the same. This extends 'Equals' in the sense that if the values are
            arrays it considers them the same if the values of the arrays are the same as well and the length is the same. 
            </summary>
            <remarks>It assumes the types of value1 and value2 are the same</remarks>
            <param name="value1">The first value to compare</param>
            <param name="value2">The second value to compare</param>
            <returns>true if the values should be considered equal. If value1 or value2 are null and the other isn't, false is returned. If both are null,
            true is returned.</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.GeneralUtils.CheckArraysAreEqual(System.Array,System.Array)">
            <summary>
            Performs a per-value compare on the arrays passed in and returns true if the arrays are of the same length and contain the same values.
            </summary>
            <param name="arr1"></param>
            <param name="arr2"></param>
            <returns>true if the arrays contain the same values and are of the same length</returns>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.GeneralUtils.PerformSyncedAction(System.Action,System.Object,System.Boolean)">
            <summary>
            Performs the specified action, either inside a lock on syncRoot if isSynchronized is true, or normally, if isSynchronized is false.
            </summary>
            <param name="toPerform">To perform.</param>
            <param name="syncRoot">The synchronize root to lock on.</param>
            <param name="isSynchronized">if set to <c>true</c> the caller is synchronized.</param>
        </member>
        <member name="M:SD.Tools.Algorithmia.UtilityClasses.GeneralUtils.PerformSyncedAction``1(System.Func{``0},System.Object,System.Boolean)">
            <summary>
            Performs the specified action, either inside a lock on syncRoot if isSynchronized is true, or normally, if isSynchronized is false.
            </summary>
            <typeparam name="T">The type of the element to return</typeparam>
            <param name="toPerform">To perform.</param>
            <param name="syncRoot">The synchronize root to lock on.</param>
            <param name="isSynchronized">if set to <c>true</c> the caller is synchronized.</param>
            <returns>the result of toPerform</returns>
        </member>
    </members>
</doc>
